{% extends "_base/navbar.html" %}
{% load datenmanagement_tags %}
{% load guardian_tags %}
{% load leaflet_tags %}
{% load static %}

{% block title %}{{ model_verbose_name_plural }} | {% endblock %}

{% block style %}
  {{ block.super }}
  {% leaflet_css plugins="locatecontrol,markercluster" %}
  <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/datamap.css' %}" />
  {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/datamap-mobile.css' %}" />
  {% else %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/datamap-desktop.css' %}" />
  {% endif %}
{% endblock %}

{% block scripts %}
  {{ block.super }}
  {% leaflet_js plugins="locatecontrol,markercluster" %}
  <script type="text/javascript" src="{% static 'proj4/proj4.js' %}"></script>
  <script type="text/javascript" src="{% static 'proj4leaflet/proj4leaflet.js' %}"></script>
  <script type="text/javascript" src="{% static 'datenmanagement/js/cartographicHelpers.js' %}"></script>
  <script type="text/javascript" src="{% static 'datenmanagement/js/genericHelpers.js' %}"></script>
{% endblock %}

{% block content %}
  <h2>{{ model_verbose_name_plural }}</h2>
  <h4><small>{{ model_description }}</small></h4>
  <h4 class="mt-3">
    <em>
      {% if objects_count > 0 %}
        Karte aller Datensätze
      {% else %}
        Keine Datensätze vorhanden!
      {% endif %}
    </em>
  </h4>
  <div class="d-grid mb-3 gap-2 d-md-block">
    {% if user|user_has_model_add_permission:model_name_lower %}
      <a class="btn btn-primary" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'add' %}"><i class="fas fa-circle-plus"></i> neuen Datensatz anlegen</a>
    {% endif %}
    {% if objects_count > 0 %}
      <a class="btn btn-secondary" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'list' %}"><i class="fas fa-table"></i> Datensätze in Tabelle auflisten</a>
    {% endif %}
    <a class="btn btn-warning" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'start' %}"><i class="fas fa-backward"></i> zurück</a>
  </div>
  {% if objects_count > 0 %}
      <div id="map-side-container" class="mb-3">
      {% leaflet_map "map" callback="window.mapCallbackFunction" %}
      {% if map_filters_enabled %}
        <div id="filter"{% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %} class="side"{% endif %}>
          <h5>Filter für Kartenobjekte</h5>
          <div id="filter-alert" class="alert alert-warning" role="alert">Filter wirken <strong>additiv</strong> (wie „UND“)</div>
          {% if map_deadlinefilter_fields %}
            <div id="filter-deadline">
              <div class="d-grid mt-2 mb-3">
                <label for="filter-input-deadline" class="form-label">Stichtag</label>
                <div class="input-group">
                  <input id="filter-input-deadline" type="date" name="deadline" class="form-control filter-input datetime-input" data-type="date" data-nullable data-intervalside="both">
                  <button class="input-reset btn btn-outline-secondary">
                    <i class="fas fa-trash" title="Filterfeld leeren"></i>
                  </button>
                </div>
              </div>
            </div>
          {% endif %}
          {% if map_rangefilter_fields and map_rangefilter_fields_labels %}
            <div id="filter-interval">
              {% for map_rangefilter_field in map_rangefilter_fields %}
                {% if not forloop.counter|divisibleby:2 %}
                  {% with naechster_index=forloop.counter0|add:1 %}
                  <div class="d-grid mt-2 mb-3">
                    <label for="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-label">{{ map_rangefilter_fields_labels|get_list_item_by_index:forloop.counter0 }}</label>
                    <div class="input-group">
                      {% if 'Date' in map_rangefilter_field|get_type_of_field:model_name %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime-local{% else %}date{% endif %}" name="{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input datetime-input" data-type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime{% else %}date{% endif %}" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="left" {% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}step="1"{% endif %}>
                        <button class="input-reset btn btn-outline-secondary">
                          <i class="fas fa-trash" title="Filterfeld leeren"></i>
                        </button>
                      {% else %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" type="text" name="{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input" data-type="text" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="left">
                      {% endif %}
                    </div>
                  </div>
                  <div class="d-grid mt-2 mb-3">
                    <label for="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" class="form-label">{{ map_rangefilter_fields_labels|get_list_item_by_index:naechster_index }}</label>
                    <div class="input-group">
                      {% if 'Date' in map_rangefilter_field|get_type_of_field:model_name %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime-local{% else %}date{% endif %}" name="{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" class="form-control filter-input datetime-input" data-type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime{% else %}date{% endif %}" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="right" {% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}step="1"{% endif %}>
                        <button class="input-reset btn btn-outline-secondary">
                          <i class="fas fa-trash" title="Filterfeld leeren"></i>
                        </button>
                      {% else %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" type="text" name="{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" class="form-control filter-input" data-type="text" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="right">
                      {% endif %}
                    </div>
                  </div>
                  {% endwith %}
                {% endif %}
              {% endfor %}
            </div>
          {% endif %}
          {% if map_filter_fields and map_filter_fields_labels %}
            <div id="filter-normal">
              {% for map_filter_field in map_filter_fields %}
                <div class="d-grid mt-2 mb-3">
                  <label for="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-label{% if map_filter_field|get_type_of_field:model_name == 'ChoiceArrayField' %} filter-checkbox-label{% endif %}">{{ map_filter_fields_labels|get_list_item_by_index:forloop.counter0 }}</label>
                  {% if 'Date' in map_filter_field|get_type_of_field:model_name %}
                    <div class="input-group">
                      <input id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" type="{% if map_filter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime-local{% else %}date{% endif %}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input datetime-input" data-type="{% if map_filter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime{% else %}date{% endif %}" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both" {% if map_filter_field|get_type_of_field:model_name == 'DateTimeField' %}step="1"{% endif %}>
                      <button class="input-reset btn btn-outline-secondary">
                        <i class="fas fa-trash" title="Filterfeld leeren"></i>
                      </button>
                    </div>
                  {% elif map_filter_field|get_type_of_field:model_name == 'BooleanField' %}
                    {% if map_filter_boolean_fields_as_checkbox %}
                      <div class="filter-input">
                        <input id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" type="checkbox" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-check-input" data-type="boolean" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both">
                      </div>
                    {% else %}
                      <div class="input-group">
                        <select id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-select filter-input" data-type="list" data-nullable data-boolean data-intervalside="both">
                          <option value="True">ja</option>
                          <option value="False">nein</option>
                        </select>
                        <button class="input-reset btn btn-outline-secondary">
                          <i class="fas fa-trash" title="Filterfeld leeren"></i>
                        </button>
                      </div>
                    {% endif %}
                  {% elif map_filter_fields_as_list and map_filter_field in map_filter_fields_as_list %}
                    <div class="input-group">
                      <select id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-select filter-input" data-type="list" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both"></select>
                      <button class="input-reset btn btn-outline-secondary">
                        <i class="fas fa-trash" title="Filterfeld leeren"></i>
                      </button>
                    </div>
                  {% elif map_filter_field|get_type_of_field:model_name == 'ChoiceArrayField' %}
                    <div class="d-grid gap-2 d-md-block">
                      Listeneinträge
                      <select id="filtertype-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-select filtertype">
                        <option value="additive">additiv (wie „UND“)</option>
                        <option value="exclusive">exklusiv (wie „ODER“)</option>
                      </select>
                      filtern
                    </div>
                    <fieldset id="filter-checkbox-fieldset-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control mt-2 filter-checkbox-fieldset" data-type="checkbox-set" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both"></fieldset>
                  {% else %}
                    <div class="input-group">
                      <input id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" type="text" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input" data-type="text" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both">
                      <button class="input-reset btn btn-outline-secondary">
                        <i class="fas fa-trash" title="Filterfeld leeren"></i>
                      </button>
                    </div>
                  {% endif %}
                </div>
              {% endfor %}
            </div>
          {% endif %}
          <div id="filter-buttons" class="d-grid mt-4 gap-2 d-md-block">
            <button id="filter-apply" class="btn btn-success" type="submit"><i class="fas fa-filter"></i> Filter anwenden</button>
            <button id="filter-reset" class="btn btn-warning" type="submit"><i class="fas fa-filter-circle-xmark"></i> Filter zurücksetzen</button>
          </div>
        </div>
      {% endif %}
      <div {% if map_filters_enabled %}id="map-control"{% endif %}{% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %} class="side"{% endif %}>
        <h5>Kartenausschnitt</h5>
        <div class="d-grid mt-2 gap-2 d-md-block">
          <button id="map-extent-filter" class="btn btn-success" type="submit"><i class="fas fa-map-location"></i> {% if map_filters_enabled %}aktuelle Filtermenge{% else %}alle Objekte{% endif %}</button>
          <button id="map-extent-initial" class="btn btn-warning" type="submit"><i class="fas fa-map"></i> gesamt</button>
        </div>
      </div>
      <div id="address-search"{% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %} class="side"{% endif %}>
        <h5>Adressensuche</h5>
        <div class="form-floating">
          <input id="searchtext" type="text" class="form-control" name="searchtext" autocapitalize="off" autocomplete="off" placeholder="Adresse, Straße oder Gemeindeteil eingeben…">
          <label for="searchtext">Adresse, Straße oder Gemeindeteil eingeben…</label>
        </div>
        <div id="results-container" class="results"></div>
      </div>
    </div>
    {% if heavy_load_limit %}
      <div id="id_mapDataLoading" class="modal fade" tabindex="-1" aria-labelledby="id_mapDataLoading-label" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header" id="id_mapDataLoading-header">
              <h5 class="modal-title" id="id_mapDataLoading-title">Laden der Kartendaten</h5>
            </div>
            <div class="modal-body" id="id_mapDataLoading-body">
              Die Kartendaten werden (nach-)geladen. Dies kann einen Moment dauern, da es sich insgesamt um eine sehr große Datenmenge handelt.
              <div class="text-center">
                <div class="spinner-border m-4 text-primary" role="status">
                  <span class="sr-only">laden…</span>
                </div>
                <div class="m-4">
                  <span id="id_mapDataLoading-count"></span> von <span id="id_mapDataLoading-border"></span> Datensätzen geladen
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    {% endif %}
    <script type="text/javascript">
      /**
       * @function
       * @name mapCallbackFunction
       *
       * behandelt als Callback-Funktion die übergebene Karte
       *
       * @param {Object} map - Karte
       */
      function mapCallbackFunction(map) {
        // Konstanten für Karte setzen
        setMapConstants(map);

        // Karte konfigurieren
        configureMap(map);

        // Karte auch in anderen Scopes bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
        window.currMap = map;

        // bei mobilen Geräten: Standortbestimmung hinzufügen
        {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
          enableMapLocate(map);
        {% endif %}

        /**
         * @function
         * @name setMapFeaturePropertiesAndActions
         *
         * definiert Aktionen und Eigenschaften für jeden Feature-Layer auf der Karte
         *
         * @param {Object} feature - Feature
         * @param {Object} layer - Feature-Layer
         */
        function setMapFeaturePropertiesAndActions(feature, layer) {
          // falls Feature einen Link auf dessen Bearbeitungsseite aufweist...
          if (feature.properties.link) {
            layer.on('click', function () {
              // Feature den Link auf dessen Bearbeitungsseite mitgeben
              window.open(feature.properties.link, '_blank').focus();
            });
          }
          // falls Feature inaktiv ist...
          if (typeof feature.properties.inaktiv !== 'undefined' && feature.properties.inaktiv) {
            // Feature vom Standard abweichend darstellen
            layer.setStyle({
              color: '#999',
              fillColor: '#999'
            });
          }
          // falls Feature-Highlighting vorgesehen ist...
          {% if highlight_flag %}
            if (typeof feature.properties.highlight !== 'undefined' && feature.properties.highlight) {
              // Feature highlighten
              layer.setStyle({
                color: '#ff0000',
                fillColor: '#ff0000'
              });
            }
          {% endif %}
          // falls Feature von initialer Feature-Ausblendung betroffen ist...
          {% if map_filter_hide_initial %}
            if (typeof feature.properties.hide_initial !== 'undefined' && feature.properties.hide_initial)
              // Feature ausblenden
              layer.setStyle({
                fill: false,
                stroke: false,
                opacity: 0
              });
          {% endif %}
          // falls Geometrie nicht punkthaft ist...
          {% if geometry_type != 'Point' %}
            // Tooltip setzen (wird ansonsten weiter unten beim Laden der GeoJSON-FeatureCollection gesetzt)
            layer.bindTooltip(feature.properties.tooltip);
          {% endif %}
        }

        // falls große Datenmenge zu erwarten ist...
        {% if heavy_load_limit %}
          // Konstanten und Variablen für die Anzahl der (bereits geholten) Features der GeoJSON-FeatureCollection definieren
          const border = {{ objects_count }};
          const limit = {{ heavy_load_limit }};
          let promises = [];
          let count = 0;
          // Zähler im Bootstrap-Modal setzen, das während des Ladevorgangs der GeoJSON-FeatureCollection für die Karte eingeblendet wird
          $('#id_mapDataLoading-count').text(count);
          $('#id_mapDataLoading-border').text(border);
        {% endif %}

        /**
         * @function
         * @name fetchGeoJsonFeatureCollection
         *
         * holt die GeoJSON-FeatureCollection für die Karte
         *
         * @param {boolean} heavyLoad - große Datenmenge zu erwarten?
         * @param {number} [limit=0] - Limit für aktuellen Ladeschritt
         * @param {number} [offset=0] - Offset für aktuellen Ladeschritt (= Vielfaches des Limits für aktuellen Ladeschritt)
         */
        async function fetchGeoJsonFeatureCollection(heavyLoad = false, limit = 0, offset = 0) {
          try {
            let url = '{% url 'datenmanagement:'|add:model_name|add:'mapdata' %}';
            // Parameter für aktuellen Ladeschritt setzen, falls große Datenmenge zu erwarten ist
            if (heavyLoad) {
              url += '?limit=' + limit + '&offset=' + offset;
            }
            toggleModal($('#id_mapDataLoading'));
            const response = await fetch(url, {
              method: 'GET'
            });
            const data = await response.json();
            if (heavyLoad) {
              count += data.features.length;
              $('#id_mapDataLoading-count').text(count);
              if (count === border) {
                toggleModal($('#id_mapDataLoading'));
              }
            } else
              toggleModal($('#id_mapDataLoading'));
            return data;
          } catch (error) {
            console.error(error);
          }
        }

        // falls Geometrie punkthaft ist...
        {% if geometry_type == 'Point' %}
          // Cluster aktivieren
          let markers = L.markerClusterGroup();
          // falls große Datenmenge zu erwarten ist...
          {% if heavy_load_limit %}
            // GeoJSON-FeatureCollection für die Karte in mehreren Ladeschritten holen, die alle parallel ausgeführt werden
            for (let offset = 0; offset < border; offset += limit) {
              promises.push(fetchGeoJsonFeatureCollection(true, limit, offset));
            }
            Promise.all(promises)
            .then(data => {
              // jedes Feature der GeoJSON-FeatureCollection mit Marker versehen, Aktionen und Eigenschaften definieren, Tooltip setzen und zum Cluster hinzufügen
              L.Proj.geoJson(data, {
                pointToLayer: function (feature, latlng) {
                  let marker = new L.circleMarker(latlng, {
                    radius: 5
                  });
                  marker.bindTooltip(feature.properties.tooltip);
                  return marker;
                },
                onEachFeature: setMapFeaturePropertiesAndActions
              }).addTo(markers);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          // ansonsten...
          {% else %}
            // GeoJSON-FeatureCollection für die Karte in einem Ladeschritt holen
            fetchGeoJsonFeatureCollection()
            .then(data => {
              // jedes Feature der GeoJSON-FeatureCollection mit Marker versehen, Aktionen und Eigenschaften definieren, Tooltip setzen und zum Cluster hinzufügen
              L.Proj.geoJson(data, {
                pointToLayer: function (feature, latlng) {
                  let marker = new L.circleMarker(latlng, {
                    radius: 5
                  });
                  marker.bindTooltip(feature.properties.tooltip);
                  return marker;
                },
                onEachFeature: setMapFeaturePropertiesAndActions
              }).addTo(markers);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          {% endif %}
          // Cluster mit eindeutiger ID versehen und zur Karte hinzufügen
          markers.id = 'cluster';
          map.addLayer(markers);
        // ansonsten...
        {% else %}
          // falls große Datenmenge zu erwarten ist...
          {% if heavy_load_limit %}
            // GeoJSON-FeatureCollection für die Karte in mehreren Ladeschritten holen, die alle parallel ausgeführt werden
            for (let offset = 0; offset < border; offset += limit) {
              promises.push(fetchGeoJsonFeatureCollection(true, limit, offset));
            }
            Promise.all(promises)
            .then(data => {
              // für jedes Feature der GeoJSON-FeatureCollection Aktionen und Eigenschaften definieren und Feature zur Karte hinzufügen
              L.Proj.geoJson(data, {
                onEachFeature: setMapFeaturePropertiesAndActions
              }).addTo(map);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          // ansonsten...
          {% else %}
            // GeoJSON-FeatureCollection für die Karte in einem Ladeschritt holen
            fetchGeoJsonFeatureCollection()
            .then(data => {
              // für jedes Feature der GeoJSON-FeatureCollection Aktionen und Eigenschaften definieren und Feature zur Karte hinzufügen
              L.Proj.geoJson(data, {
                onEachFeature: setMapFeaturePropertiesAndActions
              }).addTo(map);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          {% endif %}
        {% endif %}

        // gemeinsame Bounding-Box aller Objekte auch in anderen Scopes bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
        window.objectsExtent = map.getBounds();

        // globale Variable für gelöschte Cluster-Features auch in anderen Scopes bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
        window.removedLayers = [];

        // globale Variable für Feature-Geometrie auch in anderen Scopes bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
        window.featureGeometry = [];
      }

      /**
       * @function
       *
       * Hauptfunktion
       */
      $(document).ready(function() {
        // Variablen definieren für:
        // Bounding-Box der aktuellen Filtermenge
        // minimale und maximale Werte von entsprechenden Intervallfilterfeldern
        // Wertelisten für entsprechende Filterfelder, die als Auswahlfeld dargestellt werden sollen
        // Wertelisten für entsprechende Filterfelder, die als Checkboxen-Set dargestellt werden sollen
        let currentFilterExtent = [];
        let intervalFilterMin = [];
        let intervalFilterMax = [];
        let listFilterLists = [];
        let listFilterListsValues = {{ list_filter_lists|safe }};
        let checkboxFilterLists = [];
        let checkboxFilterListsValues = {{ checkbox_filter_lists|safe }};

        // Adressensuche initialisieren
        // dabei Resultate der Adressensuche auch in anderen Scopes bzw. außerhalb der Hauptfunktion verfügbar machen
        window.results = $('div.results');
        let searchField = $('#searchtext');
        initializeAddressSearch(searchField, '{% url "datenmanagement:addresssearch" %}');

        // über alle Filterfelder (außer Boolean- und Checkbox-Filterfelder) gehen...
        $('.filter-input').each(function() {
          // Feld als Objekt mit Name und Typ erstellen
          let filterField = {};
          filterField.name = $(this).attr('name');
          filterField.type = $(this).data('type');
          // falls es sich um ein Intervallfilterfeld handelt...
          if ($(this).data('intervalside') === 'left' || $(this).data('intervalside') === 'right') {
            // falls es sich um ein "linkes" Intervallfilterfeld (also für niedrigere/kleinere/frühere Werte) handelt...
            if ($(this).data('intervalside') === 'left') {
              // Wert des Feldobjekts entsprechend setzen
              filterField.value = '{{ interval_filter_min }}';
              // Feldobjekt zur Variable für minimale Werte von entsprechenden Intervallfilterfeldern hinzufügen
              intervalFilterMin.push(filterField);
            // falls es sich um ein "rechtes" Intervallfilterfeld (also für höhere/größere/spätere Werte) handelt...
            } else if ($(this).data('intervalside') === 'right') {
              // Wert des Feldobjekts entsprechend setzen
              filterField.value = '{{ interval_filter_max }}';
              // Feldobjekt zur Variable für maximale Werte von entsprechenden Intervallfilterfeldern hinzufügen
              intervalFilterMax.push(filterField);
            }
          // falls es sich um ein Listenfeld handelt...
          } else if ($(this).data('type') === 'list' && $(this).attr('name') in listFilterListsValues) {
            // Wert des Feldobjekts entsprechend setzen
            filterField.value = listFilterListsValues[filterField.name];
            // Feldobjekt zur Variable für Wertelisten für entsprechende Filterfelder hinzufügen, die als Auswahlfeld dargestellt werden sollen
            listFilterLists.push(filterField);
          }
        });

        // über alle Boolean-Filterfelder gehen...
        $('.filter-input input[type="checkbox"]').each(function() {
          // Feld als Objekt mit Name und Typ erstellen
          let filterField = {};
          filterField.name = $(this).attr('name');
          filterField.type = $(this).data('type');
          // Wert des Feldobjekts als Boolean setzen
          if ($(this).is(':checked')) {
            filterField.value = 'True';
          } else {
            filterField.value = 'False';
          }
          // falls es sich um ein Listenfeld handelt...
          if ($(this).attr('name') in listFilterListsValues)
            // Feldobjekt zur Variable für Wertelisten für entsprechende Filterfelder hinzufügen, die als Auswahlfeld dargestellt werden sollen
            listFilterLists.push(filterField);
        });

        // über alle Checkbox-Filterfelder gehen...
        $('.filter-checkbox-fieldset').each(function() {
          // Feld als Objekt mit Name, Typ und Wert erstellen
          let filterField = {};
          filterField.name = $(this).attr('name');
          filterField.type = $(this).data('type');
          // Wert des Feldobjekts entsprechend setzen
          filterField.value = checkboxFilterListsValues[filterField.name];
          // Feldobjekt zur Variable für Wertelisten für entsprechende Filterfelder hinzufügen, die als Checkboxen-Set dargestellt werden sollen
          checkboxFilterLists.push(filterField);
        });

        // Date-/Time-/Date-Time-Picker für jedes relevante Filterfeld initialisieren
        $('.datetime-input').each(function() {
          // Variable für initiales Datum bzw. initiales Datum mit Zeit definieren
          let initialDateTime = '';

          // falls Filterfeld in Variable für minimale Werte von entsprechenden Intervallfilterfeldern auftritt:
          // Variable für initiales Datum bzw. initiales Datum mit Zeit auf dortigen Wert setzen
          for (let i = 0; i < intervalFilterMin.length; i++) {
            if (intervalFilterMin[i].name === $(this).attr('name')) {
              initialDateTime = intervalFilterMin[i].value;
              break;
            }
          }

          // falls Filterfeld in Variable für maximale Werte von entsprechenden Intervallfilterfeldern auftritt:
          // Variable für initiales Datum bzw. initiales Datum mit Zeit auf dortigen Wert setzen
          for (let j = 0; j < intervalFilterMax.length; j++) {
            if (intervalFilterMax[j].name === $(this).attr('name')) {
              initialDateTime = intervalFilterMax[j].value;
              break;
            }
          }

          // falls Variable für initiales Datum bzw. initiales Datum mit Zeit gesetzt ist...
          if (initialDateTime !== '') {
            // initiales Datum bzw. initiales Datum mit Zeit auf entsprechenden Wert setzen
            $(this).val(initialDateTime);
            // Data-Attribut hinzufügen mit initialem Datum bzw. initialem Datum mit Zeit (benötigt beim Zurücksetzen der Filter)
            $(this).attr('data-initial', initialDateTime);
          }
        });

        // Listenfelder initialisieren
        $("select[data-type='list']").each(function() {
          // Variable für Wertelisten für entsprechende Filterfelder durchgehen, die als Auswahlfeld dargestellt werden sollen...
          for (let i = 0; i < listFilterLists.length; i++) {
            if (listFilterLists[i].name === $(this).attr('name')) {
              // falls Listenfeld nicht schon als Ja-Nein-Listenfeld vordefiniert ist...
              if (typeof $(this).data('boolean') == 'undefined') {
                // Werteliste als Optionen im Listenfeld abbilden
                for (let j = 0; j < listFilterLists[i].value.length; j++) {
                  $(this).append($('<option>', {
                    value: listFilterLists[i].value[j],
                    text: listFilterLists[i].value[j]
                  }));
                }
              }
              break;
            }
          }
          // zum Abschluss sciherstellen, dass Listenfeld initial auf leerer Option steht
          $(this).val('');
        });

        // Checkboxen-Sets initialisieren
        $('.filter-checkbox-fieldset').each(function() {
          // Variable für Wertelisten für entsprechende Filterfelder durchgehen, die als Checkboxen-Set dargestellt werden sollen...
          for (let i = 0; i < checkboxFilterLists.length; i++) {
            if (checkboxFilterLists[i].name === $(this).attr('name')) {
              // Werteliste als Checkboxen im Set abbilden
              for (let j = 0; j < checkboxFilterLists[i].value.length; j++) {
                let $label = $('<label>').attr('for', 'checkbox-' + i + '-' + j);
                $label.append($('<input>', {
                  id: 'checkbox-' + i + '-' + j,
                  class: 'form-check-input',
                  type: 'checkbox',
                  value: checkboxFilterLists[i].value[j]
                }));
                $label.append(checkboxFilterLists[i].value[j]);
                $(this).append($label);
              }
              break;
            }
          }
        });

        // bei Klick auf Button zum Anwenden der Filter...
        $('#filter-apply').on('click', function() {
          // Hinweise auf additive Wirkung der Filter anzeigen
          $('#filter-alert').show();

          // Variable für Bounding-Box der aktuellen Filtermenge leeren
          currentFilterExtent = [];

          // Variable für Liste für Filterobjekte definieren
          let filterAttributesList = [];

          // über alle Filter (außer Boolean-Filter und Checkboxen-Sets) gehen...
          $('.filter-input').each(function() {
            if ($(this).val()) {
              // Filter als Objekt mit Name, Typ, "Intervallseite" und Wert erstellen
              let filterAttribute = {};
              filterAttribute.name = $(this).attr('name');
              filterAttribute.type = $(this).data('type');
              filterAttribute.intervalside = $(this).data('intervalside');
              filterAttribute.value = $(this).val();
              // Filterobjekt zur Liste für Filterobjekte hinzufügen
              filterAttributesList.push(filterAttribute);
            }
          });

          // über alle Boolean-Filter gehen...
          $('.filter-input input[type="checkbox"]').each(function() {
            // Filter als Objekt mit Name, Typ, "Intervallseite" und Wert erstellen
            let filterAttribute = {};
            filterAttribute.name = $(this).attr('name');
            filterAttribute.type = $(this).data('type');
            filterAttribute.intervalside = $(this).data('intervalside');
            // Wert des Filterobjekts als Boolean setzen
            if ($(this).is(':checked')) {
              filterAttribute.value = 'True';
            } else {
              filterAttribute.value = 'False';
            }
            // Filterobjekt zur Liste für Filterobjekte hinzufügen
            filterAttributesList.push(filterAttribute);
          });

          // über alle Checkboxen-Sets gehen...
          $('.filter-checkbox-fieldset').each(function() {
            let checkedObjectsAtAll = false;
            // Filter als Objekt mit Name, Typ, "Intervallseite" und Wert (als Liste) erstellen
            let filterAttribute = {};
            let name = $(this).attr('name');
            filterAttribute.name = name;
            filterAttribute.type = $(this).data('type');
            filterAttribute.filtertype = $('select[id^=filtertype-' + name + ']').children('option:selected').val();
            filterAttribute.intervalside = $(this).data('intervalside');
            filterAttribute.value = [];
            // Wertliste des Filterobjekts mit dem Wert jeder aktiven Checkbox befüllen
            $(this).find('input:checked').each(function() {
              checkedObjectsAtAll = true;
              filterAttribute.value.push($(this).val());
            });
            // falls mindestens eine Checkbox im Checkboxen-Set aktiv ist...
            if (checkedObjectsAtAll)
              // Filterobjekt zur Liste für Filterobjekte hinzufügen
              filterAttributesList.push(filterAttribute);
          });

          /**
           * @function
           * @name filterMapFeatures
           *
           * filtert Layer (= Features) auf der Karte
           *
           * @param {Object} layer - Layer (= Feature)
           * @param {boolean} isSubLayer - Layer (= Feature) ist Bestandteil einer Layergruppe (= eines Clusters)?
           * @param {Object} [clusterLayer=layer] - Layergruppe (= Cluster), falls vorhanden; standardmäßig auf den Layer (= das Feature) gesetzt
           */
          function filterMapFeatures(layer, isSubLayer, clusterLayer = layer) {
            let stillVisible = true;
            for (let i = 0; i < filterAttributesList.length; i++) {
              // bei Stichtagsfilter einen entsprechenden Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
              if (filterAttributesList[i].name === 'deadline') {
                // auf passende Formatierung achten, das es sich beim Filter um einen Datumsfilter handelt!
                if (!(new Date(filterAttributesList[i].value) > new Date(layer.feature.properties['deadline_0'])) || !(new Date(layer.feature.properties['deadline_1']) > new Date(filterAttributesList[i].value)))
                  stillVisible = false;
              // bei "linkem" Intervallfilter (also für niedrigere/kleinere/frühere Werte) einen "kleiner"-Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
              } else if (filterAttributesList[i].intervalside === 'left') {
                if (filterAttributesList[i].type === 'date') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
                  if (new Date(filterAttributesList[i].value) > new Date(layer.feature.properties[filterAttributesList[i].name]))
                    stillVisible = false;
                } else if (filterAttributesList[i].type === 'datetime') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
                  if (new Date(filterAttributesList[i].value).valueOf() > new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf())
                    stillVisible = false;
                } else {
                  if (filterAttributesList[i].value > layer.feature.properties[filterAttributesList[i].name])
                    stillVisible = false;
                }
              // bei "rechtem" Intervallfilter (also für höhere/größere/spätere Werte) einen "größer"-Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
              } else if (filterAttributesList[i].intervalside === 'right') {
                if (filterAttributesList[i].type === 'date') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
                  if (new Date(layer.feature.properties[filterAttributesList[i].name]) > new Date(filterAttributesList[i].value))
                    stillVisible = false;
                } else if (filterAttributesList[i].type === 'datetime') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
                  if (new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf() > new Date(filterAttributesList[i].value).valueOf())
                    stillVisible = false;
                } else {
                  if (layer.feature.properties[filterAttributesList[i].name] > filterAttributesList[i].value)
                    stillVisible = false;
                }
              // bei Checkboxen-Sets String-Vergleich mit allen aktivierten Checkboxen durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken, falls einzelne Checkboxen additiv wirken sollen
              } else if (filterAttributesList[i].type === 'checkbox-set' && filterAttributesList[i].value.length > 0) {
                if (filterAttributesList[i].filtertype === 'additive') {
                  for (let j = 0; j < filterAttributesList[i].value.length; j++) {
                    if (layer.feature.properties[filterAttributesList[i].name].toLowerCase().indexOf(filterAttributesList[i].value[j].toLowerCase()) === -1)
                      stillVisible = false;
                  }
                } else {
                  stillVisible = false;
                  for (let k = 0; k < filterAttributesList[i].value.length; k++) {
                    if (layer.feature.properties[filterAttributesList[i].name].toLowerCase().indexOf(filterAttributesList[i].value[k].toLowerCase()) !== -1) {
                      stillVisible = true;
                      break;
                    }
                  }
                }
              // ansonsten einen Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
              } else if (filterAttributesList[i].type !== 'checkbox-set') {
                if (filterAttributesList[i].type === 'date') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
                  if (new Date(filterAttributesList[i].value).valueOf() !== new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf())
                    stillVisible = false;
                } else if (filterAttributesList[i].type === 'datetime') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Filter mit Datum und Zeit handelt!
                  if (new Date(filterAttributesList[i].value).valueOf() !== new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf())
                    stillVisible = false;
                } else if (filterAttributesList[i].type === 'list') {
                  if (layer.feature.properties[filterAttributesList[i].name].toLowerCase() !== filterAttributesList[i].value.toLowerCase())
                    stillVisible = false;
                } else {
                  if (layer.feature.properties[filterAttributesList[i].name].toLowerCase().indexOf(filterAttributesList[i].value.toLowerCase()) === -1)
                    stillVisible = false;
                }
              }
            }
            // falls Layer (= Feature) nicht zur Ausblendung vorgemerkt ist, also weiterhin sichtbar sein soll:
            if (stillVisible) {
              // Variable für Bounding-Box der aktuellen Filtermenge aktualisieren
              let north = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lat : layer.getBounds().getNorth());
              let east = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lng : layer.getBounds().getEast());
              let south = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lat : layer.getBounds().getSouth());
              let west = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lng : layer.getBounds().getWest());
              if (currentFilterExtent.length === 0) {
                currentFilterExtent[0] = [];
                currentFilterExtent[0][0] = north;
                currentFilterExtent[0][1] = east;
                currentFilterExtent[1] = [];
                currentFilterExtent[1][0] = south;
                currentFilterExtent[1][1] = west;
              } else {
                if (currentFilterExtent[0][0] > north)
                  currentFilterExtent[0][0] = north;
                if (currentFilterExtent[0][1] > east)
                  currentFilterExtent[0][1] = east;
                if (currentFilterExtent[1][0] < south)
                  currentFilterExtent[1][0] = south;
                if (currentFilterExtent[1][1] < west)
                  currentFilterExtent[1][1] = west;
              }
              // Layer (= Feature) einblenden, falls es von initialer Feature-Ausblendung betroffen ist
              {% if map_filter_hide_initial %}
                if (typeof layer.feature.properties.hide_initial !== 'undefined' && layer.feature.properties.hide_initial) {
                  layer.setStyle({
                    color: '#3388ff',
                    fill: true,
                    fillColor: '#3388ff',
                    stroke: true,
                    opacity: 1
                  });
                }
              {% endif %}
            // ansonsten:
            } else {
              // Layer (= Feature) tatsächlich ausblenden
              if (isSubLayer) {
                window.removedLayers.push(layer);
                clusterLayer.removeLayer(layer);
              } else
                layer.getElement().style.display = 'none';
            }
          }

          // über alle Filterobjekte gehen...
          if (filterAttributesList.length > 0) {
            showAllMapFeatures();
            window.currMap.eachLayer(function(layer) {
              if (layer.feature) {
                filterMapFeatures(layer, false);
              } else if (layer.id === 'cluster') {
                let clusterLayer = layer;
                layer.eachLayer(function(subLayer) {
                  filterMapFeatures(subLayer, true, clusterLayer);
                });
                layer.refreshClusters();
              }
            });
          } else {
            showAllMapFeatures();
          }
        });

        // bei Klick auf Button zum Zurücksetzen der Filter...
        $('#filter-reset').on('click', function() {
          // Hinweise auf additive Wirkung der Filter (wieder) verbergen
          $('#filter-alert').hide();

          // über alle Filterfelder (außer Boolean- und Checkbox-Filterfelder) gehen...
          $('.filter-input').each(function() {
            // falls initialer Wert vorhanden...
            if ($(this).data('initial'))
              // Filterfeld auf initialen Wert setzen
              $(this).val($(this).data('initial'));
            // ansonsten Filterfeld auf leeren Wert setzen
            else
              $(this).val('');
          });

          // über alle Boolean-Filterfelder gehen...
          $('.filter-input input[type="checkbox"]').each(function() {
            // falls initialer Wert vorhanden...
            if ($(this).data('initial')) {
              // Filterfeld auf initialen Wert setzen
              let initialValue = $(this).data('initial');
              // Boolean korrekt behandeln
              if (initialValue.toLowerCase() === 'false') {
                $(this).prop('checked', false);
              } else {
                $(this).prop('checked', true);
              }
            }
            // ansonsten Filterfeld auf leeren Wert setzen
            else {
              $(this).prop('checked', false);
            }
          });

          // über alle Checkbox-Filterfelder gehen...
          $('.filter-checkbox-fieldset').each(function() {
            // alle aktivierten Checkboxen deaktivieren
            $(this).find('input:checked').each(function() {
              $(this).prop('checked', false);
            });
          });
          // Wirkmodus aller Checkbox-Filter wieder auf Standard setzen, also additiv (wie „UND“)
          $('.filtertype').each(function() {
            $(this)[0].selectedIndex = 0;
          });

          // Bounding-Box der aktuellen Filtermenge zurücksetzen
          currentFilterExtent = [];

          // alle Layers (= Features) auf der Karte wieder anzeigen
          showAllMapFeatures();
        });

        // bei Klick auf Kreuzchen in einem Filterfeld...
        $('.input-reset').on('click', function() {
          // betreffendes Filterfeld leeren
          $(this).prev().is('button') ? $(this).prev().prev().val('') : $(this).prev().val('');
        });

        // bei Klick auf Button zum Setzen des initialen Kartenausschnitts...
        $('#map-extent-initial').on('click', function() {
          // initiales Zoomlevel aus Leaflet-Konfiguration auslesen
          let defaultZoom = String('{{ LEAFLET_CONFIG }}'.match(/DEFAULT_ZOOM(?:(?!, &#39).)*/));
          defaultZoom = defaultZoom.match(/ [0-9]+/).toString().trim();
          // initiales Kartenzentrum aus Leaflet-Konfiguration auslesen
          let defaultCenter = String('{{ LEAFLET_CONFIG }}'.match(/DEFAULT_CENTER(?:(?!, &#39).)*/));
          let defaultCenterX = String(defaultCenter.match(/ [0-9]+\.[0-9]+/)).trim();
          let defaultCenterY = String(defaultCenter.match(/[0-9]+\.[0-9]+/)).trim();
          // Kartenausschnitt mittels Kartenzentrum und Zoom-Level setzen
          setMapExtentByXYAndZoomLevel(Number(defaultCenterX), Number(defaultCenterY), Number(defaultZoom));
        });

        // bei Klick auf Button zum Setzen des Kartenausschnitts auf Bounding-Box der aktuellen Filtermenge...
        $('#map-extent-filter').on('click', function() {
          // falls Filter aktiv...
          if (currentFilterExtent.length > 0)
            // Kartenausschnitt auf Bounding-Box der aktuellen Filtermenge setzen
            setMapExtentByBoundingBox(currentFilterExtent[1][1], currentFilterExtent[1][0], currentFilterExtent[0][1], currentFilterExtent[0][0]);
          // ansonsten...
          else
            // Kartenausschnitt auf Bounding-Box aller Objekte setzen
            setMapExtentByLeafletBounds(objectsExtent);
        });

        // Höhe der Karte dynamisch setzen anhand der Höhen der Seitenbereiche
        {% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %}
          let height = $('#map-side-container').position().top;
          $('.side').each(function() {
            height += $(this).height();
          });
          $('#map-side-container').height(height);
          $('#map').height(height);
          if (typeof currMap !== 'undefined')
            currMap.invalidateSize();
        {% endif %}
      });

      /**
       * @function
       * @name showAllMapFeatures
       *
       * zeigt alle Layers (= Features) auf der Karte (wieder) an
       */
      function showAllMapFeatures() {
        currMap.eachLayer(function(layer) {
          if (layer.feature) {
            layer.getElement().style.display = '';
            // Layer (= Feature) ausblenden, falls es von initialer Feature-Ausblendung betroffen ist
            {% if map_filter_hide_initial %}
              if (typeof layer.feature.properties.hide_initial !== 'undefined' && layer.feature.properties.hide_initial) {
                layer.setStyle({
                  fill: false,
                  stroke: false,
                  opacity: 0
                });
              }
            {% endif %}
          } else if (layer.id === 'cluster') {
            layer.addLayers(window.removedLayers);
            layer.refreshClusters();
          }
        });
        window.removedLayers = [];
      }
    </script>
  {% endif %}
{% endblock %}