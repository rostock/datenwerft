{% extends "navbar.html" %}
{% load datenmanagement_tags %}
{% load leaflet_tags %}
{% load static %}

{% block title %}{{ model_verbose_name_plural }} | {% endblock %}

{% block style %}
  {{ block.super }}
  {% leaflet_css plugins="locatecontrol,markercluster" %}
  <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/map.css' %}" />
  {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/map-mobile.css' %}" />
  {% else %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/map-desktop.css' %}" />
  {% endif %}
{% endblock %}

{% block scripts %}
  {{ block.super }}
  {% leaflet_js plugins="locatecontrol,markercluster" %}
  <script type="text/javascript" src="{% static 'proj4/proj4.js' %}"></script>
  <script type="text/javascript" src="{% static 'proj4leaflet/proj4leaflet.js' %}"></script>
  <script type="text/javascript" src="{% static 'datenmanagement/js/cartographicHelpers.js' %}"></script>
  <script type="text/javascript" src="{% static 'datenmanagement/js/genericHelpers.js' %}"></script>
  <script type="text/javascript" src="{% static 'datenmanagement/js/subsetting.js' %}"></script>
  {% if map_one_click_filters %}
    <script type="text/javascript" src="{% static 'datenmanagement/js/customMapFilters.js' %}"></script>
  {% endif %}
{% endblock %}

{% block content %}
  <h2>{{ model_verbose_name_plural }}</h2>
  <h4><small>{{ model_description }}</small></h4>
  <h4 class="mt-3">
    <em>
      {% if objects_count > 0 %}
        Karte aller Datensätze
      {% else %}
        Keine Datensätze vorhanden!
      {% endif %}
    </em>
  </h4>
  <div class="d-grid mb-3 gap-2{% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %} d-md-block{% endif %}">
    {% if user|user_has_model_add_permission:model_name_lower %}
      <a class="btn btn-primary" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'_add' %}"><i class="fas fa-circle-plus"></i> neuen Datensatz anlegen</a>
    {% endif %}
    {% if objects_count > 0 %}
      <a class="btn btn-secondary" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'_list' %}"><i class="fas fa-table"></i> alle Datensätze in Tabelle auflisten</a>
      <button id="subsetter" class="btn btn-secondary" disabled><i class="fas fa-table"></i> <i class="fas fa-filter"></i> aktuelle Filtermenge in Tabelle übernehmen</button>
    {% endif %}
    <a class="btn btn-warning" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'_start' %}"><i class="fas fa-backward"></i> zurück</a>
  </div>
  {% if objects_count > 0 %}
    {% if subset_id %}
      <div class="alert alert-danger alert-dismissible fade show" role="alert">
        <i class="fa-solid fa-triangle-exclamation"></i> Es werden <strong><em>nicht alle</em></strong> Datensätze auf der Karte angezeigt, sondern nur die <strong><em>aus der Tabelle übernommenen</em></strong> Datensätze!
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
      </div>
    {% endif %}
    <div id="map-side-container" class="mb-3">
      {% leaflet_map "map" callback="window.mapCallbackFunction" %}
      {% if map_filters_enabled %}
        <div id="filter"{% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %} class="side"{% endif %}>
          <h5>Filter für Kartenobjekte</h5>
          <div id="filter-alert" class="alert alert-warning" role="alert">Filter wirken <strong>additiv</strong> (wie „UND“)</div>
          {% if map_one_click_filters %}
            <h6>Ein-Klick-Filter</h6>
            <div id="filter-one-click" class="btn-group-vertical">
              {% if model_name == 'Baustellen_geplant' %}
                <button id="baustellen-geplant-ende-nicht-abgeschlossen" class="filter-one-click-button btn btn-outline-success"><i class="fas fa-gears"></i> beendet, aber Status != abgeschlossen</button>
                <button id="baustellen-geplant-beginn-nicht-imbau" class="filter-one-click-button btn btn-outline-success"><i class="fas fa-gears"></i> begonnen (nicht beendet), aber Status != im Bau (LP8)</button>
              {% endif %}
            </div>
            <hr/>
          {% endif %}
          {% if map_deadlinefilter_fields %}
            <div id="filter-deadline">
              <div class="d-grid mt-2 mb-3">
                <label for="filter-input-deadline" class="form-label">Stichtag</label>
                <div class="input-group">
                  <input id="filter-input-deadline" type="date" name="deadline" class="form-control filter-input datetime-input" data-type="date" data-nullable data-intervalside="both" data-logic="positive"/>
                  <button class="input-reset btn btn-outline-secondary">
                    <i class="fas fa-trash" title="Filterfeld leeren"></i>
                  </button>
                </div>
              </div>
            </div>
          {% endif %}
          {% if map_rangefilter_fields and map_rangefilter_fields_labels %}
            <div id="filter-interval">
              {% for map_rangefilter_field in map_rangefilter_fields %}
                {% if not forloop.counter|divisibleby:2 %}
                  {% with naechster_index=forloop.counter0|add:1 %}
                  <div class="d-grid mt-2 mb-3">
                    <label for="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-label">{{ map_rangefilter_fields_labels|get_list_item_by_index:forloop.counter0 }}</label>
                    <div class="input-group">
                      {% if 'Date' in map_rangefilter_field|get_type_of_field:model_name %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime-local{% else %}date{% endif %}" name="{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input datetime-input" data-type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime{% else %}date{% endif %}" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="left" data-logic="positive" {% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}step="1"{% endif %}/>
                        <button class="input-reset btn btn-outline-secondary">
                          <i class="fas fa-trash" title="Filterfeld leeren"></i>
                        </button>
                      {% else %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" type="text" name="{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input" data-type="text" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="left" data-logic="positive"/>
                      {% endif %}
                    </div>
                  </div>
                  <div class="d-grid mt-2 mb-3">
                    <label for="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" class="form-label">{{ map_rangefilter_fields_labels|get_list_item_by_index:naechster_index }}</label>
                    <div class="input-group">
                      {% if 'Date' in map_rangefilter_field|get_type_of_field:model_name %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime-local{% else %}date{% endif %}" name="{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" class="form-control filter-input datetime-input" data-type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime{% else %}date{% endif %}" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="right" data-logic="positive" {% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}step="1"{% endif %}/>
                        <button class="input-reset btn btn-outline-secondary">
                          <i class="fas fa-trash" title="Filterfeld leeren"></i>
                        </button>
                      {% else %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" type="text" name="{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" class="form-control filter-input" data-type="text" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="right" data-logic="positive"/>
                      {% endif %}
                    </div>
                  </div>
                  {% endwith %}
                {% endif %}
              {% endfor %}
            </div>
          {% endif %}
          {% if map_filter_fields and map_filter_fields_labels %}
            <div id="filter-normal">
              {% for map_filter_field in map_filter_fields %}
                <div class="d-grid mt-2 mb-3">
                  <label for="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-label{% if map_filter_field|get_type_of_field:model_name == 'ChoiceArrayField' %} filter-checkbox-label{% endif %}">{{ map_filter_fields_labels|get_list_item_by_index:forloop.counter0 }}</label>
                  {% if 'Date' in map_filter_field|get_type_of_field:model_name %}
                    <div class="input-group">
                      <input id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" type="{% if map_filter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime-local{% else %}date{% endif %}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input datetime-input" data-type="{% if map_filter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime{% else %}date{% endif %}" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both" data-logic="positive" {% if map_filter_field|get_type_of_field:model_name == 'DateTimeField' %}step="1"{% endif %}/>
                      <button class="input-reset btn btn-outline-secondary">
                        <i class="fas fa-trash" title="Filterfeld leeren"></i>
                      </button>
                    </div>
                  {% elif map_filter_field|get_type_of_field:model_name == 'BooleanField' %}
                    {% if map_filter_boolean_fields_as_checkbox %}
                      <div class="filter-input">
                        <input id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" type="checkbox" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-check-input" data-type="boolean" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both" data-logic="positive"/>
                      </div>
                    {% else %}
                      <div class="input-group">
                        <select id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-select filter-input" data-type="list" data-nullable data-boolean data-intervalside="both" data-logic="positive">
                          <option value="True">ja</option>
                          <option value="False">nein</option>
                        </select>
                        <button class="input-reset btn btn-outline-secondary">
                          <i class="fas fa-trash" title="Filterfeld leeren"></i>
                        </button>
                      </div>
                    {% endif %}
                  {% elif map_filter_fields_as_list and map_filter_field in map_filter_fields_as_list %}
                    <div class="input-group">
                      <select id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-select filter-input" data-type="list" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both" data-logic="positive"></select>
                      <button class="input-reset btn btn-outline-secondary">
                        <i class="fas fa-trash" title="Filterfeld leeren"></i>
                      </button>
                    </div>
                  {% elif map_filter_field|get_type_of_field:model_name == 'ChoiceArrayField' or map_filter_fields_as_checkbox and map_filter_field in map_filter_fields_as_checkbox %}
                    <div class="d-grid gap-2 d-md-block">
                      {% if map_filter_field|get_type_of_field:model_name == 'ChoiceArrayField' %}
                        Listeneinträge
                        <select id="filtertype-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-select filtertype">
                          <option value="additive">additiv (wie „UND“)</option>
                          <option value="exclusive">exklusiv (wie „ODER“)</option>
                        </select>
                        filtern
                      {% else %}
                        Listeneinträge werden exklusiv (wie „ODER“) gefiltert
                      {% endif %}
                    </div>
                    <fieldset id="filter-checkbox-fieldset-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control mt-2 filter-checkbox-fieldset" data-type="checkbox-set" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both" data-logic="positive"></fieldset>
                  {% else %}
                    <div class="input-group">
                      <input id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" type="text" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input" data-type="text" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both" data-logic="positive"/>
                      <button class="input-reset btn btn-outline-secondary">
                        <i class="fas fa-trash" title="Filterfeld leeren"></i>
                      </button>
                    </div>
                  {% endif %}
                </div>
              {% endfor %}
            </div>
          {% endif %}
          <div id="filter-buttons" class="d-grid mt-4 gap-2 d-md-block">
            <button id="filter-apply" class="btn btn-success"><i class="fas fa-filter"></i> Filter anwenden</button>
            <button id="filter-reset" class="btn btn-warning"><i class="fas fa-filter-circle-xmark"></i> Filter zurücksetzen</button>
          </div>
        </div>
      {% endif %}
      <div {% if map_filters_enabled %}id="map-control"{% endif %}{% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %} class="side"{% endif %}>
        <h5>Kartenausschnitt</h5>
        <div class="d-grid mt-2 gap-2 d-md-block">
          <button id="map-extent-filter" class="btn btn-success"><i class="fas fa-map-location"></i> {% if map_filters_enabled %}aktuelle Filtermenge{% else %}alle Objekte{% endif %}</button>
          <button id="map-extent-initial" class="btn btn-warning"><i class="fas fa-map"></i> gesamt</button>
        </div>
      </div>
      <div id="address-search"{% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %} class="side"{% endif %}>
        <h5>Adressensuche</h5>
        <div class="form-floating">
          <input id="searchtext" type="text" class="form-control" name="searchtext" autocapitalize="off" autocomplete="off" placeholder="Adresse, Straße oder Gemeindeteil eingeben…"/>
          <label for="searchtext">Adresse, Straße oder Gemeindeteil eingeben…</label>
        </div>
        <div id="results-container" class="results"></div>
      </div>
    </div>
    <div id="subsetter-error-modal" class="modal fade" tabindex="-1" aria-labelledby="subsetter-error-modal-label" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header" id="subsetter-error-modal-header">
              <h5 class="modal-title" id="subsetter-error-modal-title">Keine Übernahme der aktuellen Filtermenge in die Tabelle möglich!</h5>
          </div>
          <div class="modal-body" id="subsetter-error-modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
          </div>
        </div>
      </div>
    </div>
    {% if heavy_load_limit %}
      <div id="map-data-loading-modal" class="modal fade" tabindex="-1" aria-labelledby="map-data-loading-modal-label" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header" id="map-data-loading-modal-header">
              <h5 class="modal-title" id="map-data-loading-modal-title">Laden der Kartendaten</h5>
            </div>
            <div class="modal-body" id="map-data-loading-modal-body">
              Die Kartendaten werden (nach-)geladen. Dies kann einen Moment dauern, da es sich insgesamt um eine sehr große Datenmenge handelt.
              <div class="text-center">
                <div class="spinner-border m-4 text-primary" role="status">
                  <span class="sr-only">laden…</span>
                </div>
                <div class="m-4">
                  <span id="map-data-loading-modal-count"></span> von <span id="map-data-loading-modal-border"></span> Datensätzen geladen
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    {% endif %}
    <script type="text/javascript">
      /**
       * @function
       * @name mapCallbackFunction
       *
       * behandelt als Callback-Funktion die übergebene Karte
       *
       * @param {Object} map - Karte
       */
      function mapCallbackFunction(map) {
        // Konstanten für Karte setzen
        setMapConstants(map);

        // Karte konfigurieren
        configureMap(map, '{% url "toolbox:owsproxy" %}');

        // Karte auch in anderen Scopes bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
        window.currMap = map;

        // bei mobilen Geräten: Standortbestimmung hinzufügen
        {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
          enableMapLocate(map);
        {% endif %}

        /**
         * @function
         * @name setMapFeaturePropertiesAndActions
         *
         * definiert Aktionen und Eigenschaften für jeden Feature-Layer auf der Karte
         *
         * @param {Object} feature - Feature
         * @param {Object} layer - Feature-Layer
         */
        function setMapFeaturePropertiesAndActions(feature, layer) {
          // falls Feature einen Link auf dessen Bearbeitungsseite aufweist...
          if (feature.properties.link) {
            layer.on('click', function () {
              // Feature den Link auf dessen Bearbeitungsseite mitgeben
              window.open(feature.properties.link, '_blank', 'noopener,noreferrer').focus();
            });
          }
          // falls Feature inaktiv ist...
          if (typeof feature.properties.inaktiv !== 'undefined' && feature.properties.inaktiv) {
            // Feature vom Standard abweichend darstellen
            layer.setStyle({
              color: '#999',
              fillColor: '#999'
            });
          }
          // falls Feature-Highlighting vorgesehen ist...
          {% if highlight_flag %}
            if (typeof feature.properties.highlight !== 'undefined' && feature.properties.highlight) {
              // Feature highlighten
              layer.setStyle({
                color: '#ff0000',
                fillColor: '#ff0000'
              });
            }
          {% endif %}
          // falls Feature von initialer Feature-Ausblendung betroffen ist...
          {% if map_filter_hide_initial %}
            if (typeof feature.properties.hide_initial !== 'undefined' && feature.properties.hide_initial)
              // Feature ausblenden
              layer.setStyle({
                fill: false,
                stroke: false,
                opacity: 0
              });
          {% endif %}
          // falls Geometrie nicht punkthaft ist...
          {% if geometry_type != 'Point' %}
            // Tooltip setzen (wird ansonsten weiter unten beim Laden der GeoJSON-FeatureCollection gesetzt)
            layer.bindTooltip(feature.properties.tooltip);
          {% endif %}
        }

        // falls große Datenmenge zu erwarten ist...
        {% if heavy_load_limit %}
          // Konstanten und Variablen für die Anzahl der (bereits geholten) Features der GeoJSON-FeatureCollection definieren
          const border = {{ objects_count }};
          const limit = {{ heavy_load_limit }};
          let promises = [];
          let count = 0;
          // Zähler im Bootstrap-Modal setzen, das während des Ladevorgangs der GeoJSON-FeatureCollection für die Karte eingeblendet wird
          $('#map-data-loading-modal-count').text(count);
          $('#map-data-loading-modal-border').text(border);
        {% endif %}

        /**
         * @function
         * @name fetchGeoJsonFeatureCollection
         *
         * holt die GeoJSON-FeatureCollection für die Karte
         *
         * @param {boolean} heavyLoad - große Datenmenge zu erwarten?
         * @param {number} [limit=0] - Limit für aktuellen Ladeschritt
         * @param {number} [offset=0] - Offset für aktuellen Ladeschritt (= Vielfaches des Limits für aktuellen Ladeschritt)
         */
        async function fetchGeoJsonFeatureCollection(heavyLoad = false, limit = 0, offset = 0) {
          try {
            let url = "{% url 'datenmanagement:'|add:model_name|add:'_mapdata' %}";
            {% if subset_id %}
             url = "{% url 'datenmanagement:'|add:model_name|add:'_mapdata'|add:'_subset' subset_id %}";
            {% endif %}
            // Parameter für aktuellen Ladeschritt setzen, falls große Datenmenge zu erwarten ist
            if (heavyLoad) {
              url += '?limit=' + limit + '&offset=' + offset;
            }
            toggleModal($('#map-data-loading-modal'));
            const response = await fetch(url, {
              method: 'GET'
            });
            const data = await response.json();
            if (heavyLoad) {
              count += data.features.length;
              $('#map-data-loading-modal-count').text(count);
              if (count === border) {
                toggleModal($('#map-data-loading-modal'));
              }
            } else
              toggleModal($('#map-data-loading-modal'));
            return data;
          } catch (error) {
            console.error(error);
          }
        }

        // falls Geometrie punkthaft ist...
        {% if geometry_type == 'Point' %}
          // Cluster aktivieren
          let markers = L.markerClusterGroup();
          // falls große Datenmenge zu erwarten ist...
          {% if heavy_load_limit %}
            // GeoJSON-FeatureCollection für die Karte in mehreren Ladeschritten holen, die alle parallel ausgeführt werden
            for (let offset = 0; offset < border; offset += limit) {
              promises.push(fetchGeoJsonFeatureCollection(true, limit, offset));
            }
            Promise.all(promises)
            .then(data => {
              // jedes Feature der GeoJSON-FeatureCollection mit Marker versehen, Aktionen und Eigenschaften definieren, Tooltip setzen und zum Cluster hinzufügen
              L.Proj.geoJson(data, {
                pointToLayer: function (feature, latlng) {
                  let marker = new L.circleMarker(latlng, {
                    radius: 5
                  });
                  marker.bindTooltip(feature.properties.tooltip);
                  return marker;
                },
                onEachFeature: setMapFeaturePropertiesAndActions
              }).addTo(markers);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          // ansonsten...
          {% else %}
            // GeoJSON-FeatureCollection für die Karte in einem Ladeschritt holen
            fetchGeoJsonFeatureCollection()
            .then(data => {
              // jedes Feature der GeoJSON-FeatureCollection mit Marker versehen, Aktionen und Eigenschaften definieren, Tooltip setzen und zum Cluster hinzufügen
              L.Proj.geoJson(data, {
                pointToLayer: function (feature, latlng) {
                  let marker = new L.circleMarker(latlng, {
                    radius: 5
                  });
                  marker.bindTooltip(feature.properties.tooltip);
                  return marker;
                },
                onEachFeature: setMapFeaturePropertiesAndActions
              }).addTo(markers);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          {% endif %}
          // Cluster mit eindeutiger ID versehen und zur Karte hinzufügen
          markers.id = 'cluster';
          map.addLayer(markers);
        // ansonsten...
        {% else %}
          // falls große Datenmenge zu erwarten ist...
          {% if heavy_load_limit %}
            // GeoJSON-FeatureCollection für die Karte in mehreren Ladeschritten holen, die alle parallel ausgeführt werden
            for (let offset = 0; offset < border; offset += limit) {
              promises.push(fetchGeoJsonFeatureCollection(true, limit, offset));
            }
            Promise.all(promises)
            .then(data => {
              // für jedes Feature der GeoJSON-FeatureCollection Aktionen und Eigenschaften definieren und Feature zur Karte hinzufügen
              L.Proj.geoJson(data, {
                onEachFeature: setMapFeaturePropertiesAndActions
              }).addTo(map);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          // ansonsten...
          {% else %}
            // GeoJSON-FeatureCollection für die Karte in einem Ladeschritt holen
            fetchGeoJsonFeatureCollection()
            .then(data => {
              // für jedes Feature der GeoJSON-FeatureCollection Aktionen und Eigenschaften definieren und Feature zur Karte hinzufügen
              L.Proj.geoJson(data, {
                onEachFeature: setMapFeaturePropertiesAndActions
              }).addTo(map);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          {% endif %}
        {% endif %}

        // gemeinsame Bounding-Box aller Objekte auch in anderen Scopes bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
        window.objectsExtent = map.getBounds();

        // globale Variable für gelöschte Cluster-Features auch in anderen Scopes bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
        window.removedLayers = [];

        // globale Variable für Feature-Geometrie auch in anderen Scopes bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
        window.featureGeometry = [];
      }

      /**
       * @function
       *
       * Hauptfunktion
       */
      $(document).ready(function() {
        // Variablen definieren für:
        // Primärschlüssel der aktuellen Filtermenge
        // Bounding-Box der aktuellen Filtermenge
        // minimale und maximale Werte von entsprechenden Intervallfilterfeldern
        // Wertelisten für entsprechende Filterfelder, die als Listenfilter dargestellt werden sollen
        // Wertelisten für entsprechende Filterfelder, die als Checkboxen-Set dargestellt werden sollen
        window.currentFilterPrimaryKeys = [];
        window.currentFilterExtent = [];
        let intervalFilterMin = [];
        let intervalFilterMax = [];
        let listFilterLists = [];
        let listFilterListsValues = {{ list_filter_lists|safe }};
        let checkboxFilterLists = [];
        let checkboxFilterListsValues = {{ checkbox_filter_lists|safe }};

        // Adressensuche initialisieren
        // dabei Resultate der Adressensuche auch in anderen Scopes bzw. außerhalb der Hauptfunktion verfügbar machen
        window.results = $('div.results');
        let searchField = $('#searchtext');
        initializeAddressSearch(searchField, '{% url "toolbox:addresssearch" %}');

        // über alle Filterfelder (außer Boolean- und Checkbox-Filterfelder) gehen...
        $('.filter-input').each(function() {
          // Feld als Objekt mit Name und Typ erstellen
          let filterField = {};
          filterField.name = $(this).attr('name');
          filterField.type = $(this).data('type');
          // falls es sich um ein Intervallfilterfeld handelt...
          if ($(this).data('intervalside') === 'left' || $(this).data('intervalside') === 'right') {
            // falls es sich um ein "linkes" Intervallfilterfeld (also für niedrigere/kleinere/frühere Werte) handelt...
            if ($(this).data('intervalside') === 'left') {
              // Wert des Feldobjekts entsprechend setzen
              filterField.value = '{{ interval_filter_min }}';
              // Feldobjekt zur Variable für minimale Werte von entsprechenden Intervallfilterfeldern hinzufügen
              intervalFilterMin.push(filterField);
            // falls es sich um ein "rechtes" Intervallfilterfeld (also für höhere/größere/spätere Werte) handelt...
            } else if ($(this).data('intervalside') === 'right') {
              // Wert des Feldobjekts entsprechend setzen
              filterField.value = '{{ interval_filter_max }}';
              // Feldobjekt zur Variable für maximale Werte von entsprechenden Intervallfilterfeldern hinzufügen
              intervalFilterMax.push(filterField);
            }
          // falls es sich um ein Listenfeld handelt...
          } else if ($(this).data('type') === 'list' && $(this).attr('name') in listFilterListsValues) {
            // Wert des Feldobjekts entsprechend setzen
            filterField.value = listFilterListsValues[filterField.name];
            // Feldobjekt zur Variable für Wertelisten für entsprechende Filterfelder hinzufügen, die als Listenfilter dargestellt werden sollen
            listFilterLists.push(filterField);
          }
        });

        // über alle Boolean-Filterfelder gehen...
        $('.filter-input input[type="checkbox"]').each(function() {
          // Feld als Objekt mit Name und Typ erstellen
          let filterField = {};
          filterField.name = $(this).attr('name');
          filterField.type = $(this).data('type');
          // Wert des Feldobjekts als Boolean setzen
          if ($(this).is(':checked')) {
            filterField.value = 'True';
          } else {
            filterField.value = 'False';
          }
          // falls es sich um ein Listenfeld handelt...
          if ($(this).attr('name') in listFilterListsValues)
            // Feldobjekt zur Variable für Wertelisten für entsprechende Filterfelder hinzufügen, die als Listenfilter dargestellt werden sollen
            listFilterLists.push(filterField);
        });

        // über alle Checkbox-Filterfelder gehen...
        $('.filter-checkbox-fieldset').each(function() {
          // Feld als Objekt mit Name, Typ und Wert erstellen
          let filterField = {};
          filterField.name = $(this).attr('name');
          filterField.type = $(this).data('type');
          // Wert des Feldobjekts entsprechend setzen
          filterField.value = checkboxFilterListsValues[filterField.name];
          // Feldobjekt zur Variable für Wertelisten für entsprechende Filterfelder hinzufügen, die als Checkboxen-Set dargestellt werden sollen
          checkboxFilterLists.push(filterField);
        });

        // Date-/Time-/Date-Time-Picker für jedes relevante Filterfeld initialisieren
        $('.datetime-input').each(function() {
          // Variable für initiales Datum bzw. initiales Datum mit Zeit definieren
          let initialDateTime = '';

          // falls Filterfeld in Variable für minimale Werte von entsprechenden Intervallfilterfeldern auftritt:
          // Variable für initiales Datum bzw. initiales Datum mit Zeit auf dortigen Wert setzen
          for (let i = 0; i < intervalFilterMin.length; i++) {
            if (intervalFilterMin[i].name === $(this).attr('name')) {
              initialDateTime = intervalFilterMin[i].value;
              break;
            }
          }

          // falls Filterfeld in Variable für maximale Werte von entsprechenden Intervallfilterfeldern auftritt:
          // Variable für initiales Datum bzw. initiales Datum mit Zeit auf dortigen Wert setzen
          for (let j = 0; j < intervalFilterMax.length; j++) {
            if (intervalFilterMax[j].name === $(this).attr('name')) {
              initialDateTime = intervalFilterMax[j].value;
              break;
            }
          }

          // falls Variable für initiales Datum bzw. initiales Datum mit Zeit gesetzt ist...
          if (initialDateTime !== '') {
            // initiales Datum bzw. initiales Datum mit Zeit auf entsprechenden Wert setzen
            $(this).val(initialDateTime);
            // Data-Attribut hinzufügen mit initialem Datum bzw. initialem Datum mit Zeit (benötigt beim Zurücksetzen der Filter)
            $(this).attr('data-initial', initialDateTime);
          }
        });

        // Listenfelder initialisieren
        $("select[data-type='list']").each(function() {
          // Variable für Wertelisten für entsprechende Filterfelder durchgehen, die als Listenfilter dargestellt werden sollen...
          for (let i = 0; i < listFilterLists.length; i++) {
            if (listFilterLists[i].name === $(this).attr('name')) {
              // falls Listenfeld nicht schon als Ja-Nein-Listenfeld vordefiniert ist...
              if (typeof $(this).data('boolean') == 'undefined') {
                // Werteliste als Optionen im Listenfeld abbilden
                for (let j = 0; j < listFilterLists[i].value.length; j++) {
                  $(this).append($('<option>', {
                    value: listFilterLists[i].value[j],
                    text: listFilterLists[i].value[j]
                  }));
                }
              }
              break;
            }
          }
          // zum Abschluss sciherstellen, dass Listenfeld initial auf leerer Option steht
          $(this).val('');
        });

        // Checkboxen-Sets initialisieren
        $('.filter-checkbox-fieldset').each(function() {
          // Variable für Wertelisten für entsprechende Filterfelder durchgehen, die als Checkboxen-Set dargestellt werden sollen...
          for (let i = 0; i < checkboxFilterLists.length; i++) {
            if (checkboxFilterLists[i].name === $(this).attr('name')) {
              // Werteliste als Checkboxen im Set abbilden
              for (let j = 0; j < checkboxFilterLists[i].value.length; j++) {
                let $label = $('<label>').attr('for', 'checkbox-' + i + '-' + j);
                $label.append($('<input>', {
                  id: 'checkbox-' + i + '-' + j,
                  class: 'form-check-input',
                  type: 'checkbox',
                  value: checkboxFilterLists[i].value[j]
                }));
                $label.append(checkboxFilterLists[i].value[j]);
                $(this).append($label);
              }
              break;
            }
          }
        });

        // bei Klick auf einen Ein-Klick-Filter-Button...
        $('.filter-one-click-button').on('click', function(e) {
          let $this = $(this);

          // Button zur Übergabe der aktuellen Filtermenge an Tabellenansicht aktivieren
          $('#subsetter').prop('disabled', false);

          // alle übrigen Ein-Klick-Filter-Buttons deaktivieren
          $this.parent().children('button').each(function() {
            if ($(this).attr('id') !== e.target.id) {
              $(this).prop('disabled', true);
            }
          });

          // Button zum Anwenden der Filter deaktivieren
          $('#filter-apply').prop('disabled', true);

          // Liste für Filterobjekte definieren und befüllen
          let filterAttributesList = customMapFilters(e.target.id);

          // Filter anwenden
          applyFilters(filterAttributesList);
        });

        // bei Klick auf Button zum Anwenden der Filter...
        $('#filter-apply').on('click', function() {
          // Button zur Übergabe der aktuellen Filtermenge an Tabellenansicht aktivieren
          $('#subsetter').prop('disabled', false);

          // alle Ein-Klick-Filter-Buttons deaktivieren
          $('#filter-one-click').children('button').each(function() {
            $(this).prop('disabled', true);
          });

          // Variable für Liste für Filterobjekte definieren
          let filterAttributesList = [];

          // Primärschlüssel der aktuellen Filtermenge zurücksetzen
          window.currentFilterPrimaryKeys = [];

          // Bounding-Box der aktuellen Filtermenge zurücksetzen
          window.currentFilterExtent = [];

          // Hinweise auf additive Wirkung der Filter anzeigen
          $('#filter-alert').show();

          // über alle Filter (außer Boolean-Filter und Checkboxen-Sets) gehen...
          $('.filter-input').each(function() {
            if ($(this).val()) {
              // Filter als Objekt mit Name, Typ, "Intervallseite" und Wert erstellen
              let filterAttribute = {};
              filterAttribute.name = $(this).attr('name');
              filterAttribute.type = $(this).data('type');
              filterAttribute.intervalside = $(this).data('intervalside');
              filterAttribute.value = $(this).val();
              // Filterobjekt zur Liste für Filterobjekte hinzufügen
              filterAttributesList.push(filterAttribute);
            }
          });

          // über alle Boolean-Filter gehen...
          $('.filter-input input[type="checkbox"]').each(function() {
            // Filter als Objekt mit Name, Typ, "Intervallseite" und Wert erstellen
            let filterAttribute = {};
            filterAttribute.name = $(this).attr('name');
            filterAttribute.type = $(this).data('type');
            filterAttribute.intervalside = $(this).data('intervalside');
            // Wert des Filterobjekts als Boolean setzen
            if ($(this).is(':checked')) {
              filterAttribute.value = 'True';
            } else {
              filterAttribute.value = 'False';
            }
            // Filterobjekt zur Liste für Filterobjekte hinzufügen
            filterAttributesList.push(filterAttribute);
          });

          // über alle Checkboxen-Sets gehen...
          $('.filter-checkbox-fieldset').each(function() {
            let checkedObjectsAtAll = false;
            // Filter als Objekt mit Name, Typ, "Intervallseite" und Wert (als Liste) erstellen
            let filterAttribute = {};
            let name = $(this).attr('name');
            filterAttribute.name = name;
            filterAttribute.type = $(this).data('type');
            // Wirkung der Filter (additiv oder exklusiv) entweder aus entsprechendem Auswahlfeld auslesen
            // oder direkt als exklusiv festlegen, wenn kein entsprechendes Auswahlfeld existiert
            if ($('select[id^=filtertype-' + name + ']').length)
              filterAttribute.filtertype = $('select[id^=filtertype-' + name + ']').children('option:selected').val();
            else
              filterAttribute.filtertype = 'exclusive';
            filterAttribute.intervalside = $(this).data('intervalside');
            filterAttribute.value = [];
            // Wertliste des Filterobjekts mit dem Wert jeder aktiven Checkbox befüllen
            $(this).find('input:checked').each(function() {
              checkedObjectsAtAll = true;
              filterAttribute.value.push($(this).val());
            });
            // falls mindestens eine Checkbox im Checkboxen-Set aktiv ist...
            if (checkedObjectsAtAll)
              // Filterobjekt zur Liste für Filterobjekte hinzufügen
              filterAttributesList.push(filterAttribute);
          });

          // Filter anwenden
          applyFilters(filterAttributesList);
        });

        // bei Klick auf Button zum Zurücksetzen der Filter...
        $('#filter-reset').on('click', function() {
          // alle Ein-Klick-Filter-Buttons (wieder) aktivieren
          $('#filter-one-click').children('button').each(function() {
            $(this).prop('disabled', false);
          });

          // Button zum Anwenden der Filter (wieder) aktivieren
          $('#filter-apply').prop('disabled', false);

          // Button zur Übergabe der aktuellen Filtermenge an Tabellenansicht deaktivieren
          $('#subsetter').prop('disabled', true);

          // Hinweise auf additive Wirkung der Filter (wieder) verbergen
          $('#filter-alert').hide();

          // über alle Filterfelder (außer Boolean- und Checkbox-Filterfelder) gehen...
          $('.filter-input').each(function() {
            // falls initialer Wert vorhanden...
            if ($(this).data('initial'))
              // Filterfeld auf initialen Wert setzen
              $(this).val($(this).data('initial'));
            // ansonsten Filterfeld auf leeren Wert setzen
            else
              $(this).val('');
          });

          // über alle Boolean-Filterfelder gehen...
          $('.filter-input input[type="checkbox"]').each(function() {
            // falls initialer Wert vorhanden...
            if ($(this).data('initial')) {
              // Filterfeld auf initialen Wert setzen
              let initialValue = $(this).data('initial');
              // Boolean korrekt behandeln
              if (initialValue.toLowerCase() === 'false') {
                $(this).prop('checked', false);
              } else {
                $(this).prop('checked', true);
              }
            }
            // ansonsten Filterfeld auf leeren Wert setzen
            else {
              $(this).prop('checked', false);
            }
          });

          // über alle Checkbox-Filterfelder gehen...
          $('.filter-checkbox-fieldset').each(function() {
            // alle aktivierten Checkboxen deaktivieren
            $(this).find('input:checked').each(function() {
              $(this).prop('checked', false);
            });
          });
          // Wirkmodus aller Checkbox-Filter wieder auf Standard setzen, also additiv (wie „UND“)
          $('.filtertype').each(function() {
            $(this)[0].selectedIndex = 0;
          });

          // Primärschlüssel der aktuellen Filtermenge zurücksetzen
          window.currentFilterPrimaryKeys = [];

          // Bounding-Box der aktuellen Filtermenge zurücksetzen
          window.currentFilterExtent = [];

          // alle Layers (= Features) auf der Karte wieder anzeigen
          showAllMapFeatures();
        });

        // bei Klick auf Kreuzchen in einem Filterfeld...
        $('.input-reset').on('click', function() {
          // betreffendes Filterfeld leeren
          $(this).prev().is('button') ? $(this).prev().prev().val('') : $(this).prev().val('');
        });

        // bei Klick auf Button zum Setzen des initialen Kartenausschnitts...
        $('#map-extent-initial').on('click', function() {
          // initiales Zoomlevel aus Leaflet-Konfiguration auslesen
          let defaultZoom = String('{{ LEAFLET_CONFIG }}'.match(/DEFAULT_ZOOM(?:(?!, &#39).)*/));
          defaultZoom = defaultZoom.match(/ [0-9]+/).toString().trim();
          // initiales Kartenzentrum aus Leaflet-Konfiguration auslesen
          let defaultCenter = String('{{ LEAFLET_CONFIG }}'.match(/DEFAULT_CENTER(?:(?!, &#39).)*/));
          let defaultCenterX = String(defaultCenter.match(/ [0-9]+\.[0-9]+/)).trim();
          let defaultCenterY = String(defaultCenter.match(/[0-9]+\.[0-9]+/)).trim();
          // Kartenausschnitt mittels Kartenzentrum und Zoom-Level setzen
          setMapExtentByXYAndZoomLevel(Number(defaultCenterX), Number(defaultCenterY), Number(defaultZoom));
        });

        // bei Klick auf Button zum Setzen des Kartenausschnitts auf Bounding-Box der aktuellen Filtermenge...
        $('#map-extent-filter').on('click', function() {
          // falls Filter aktiv...
          if (window.currentFilterExtent.length > 0)
            // Kartenausschnitt auf Bounding-Box der aktuellen Filtermenge setzen
            setMapExtentByBoundingBox(window.currentFilterExtent[1][1], window.currentFilterExtent[1][0], window.currentFilterExtent[0][1], window.currentFilterExtent[0][0]);
          // ansonsten...
          else
            // Kartenausschnitt auf Bounding-Box aller Objekte setzen
            setMapExtentByLeafletBounds(objectsExtent);
        });

        // bei Klick auf Button zur Übergabe der aktuellen Filtermenge an Tabellenansicht...
        $('#subsetter').on('click', function() {
          // Filtermenge behandeln und übergeben
          {% with tmp='foobar' %}
            let url_mask = "{% url 'datenmanagement:'|add:model_name|add:'_list'|add:'_subset' tmp %}";
          {% endwith %}
          subsetting(
            window.currentFilterPrimaryKeys,
            '{% url "toolbox:subset_add" %}',
            '{{ model_name }}',
            '{{ model_pk_field }}',
            url_mask,
            'Bei der Übernahme der aktuellen Filtermenge in die Tabelle ist ein Serverfehler aufgetreten.'
          );
        });

        // Höhe der Karte dynamisch setzen anhand der Höhen der Seitenbereiche
        {% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %}
          let height = $('#map-side-container').position().top;
          $('.side').each(function() {
            height += $(this).height();
          });
          $('#map-side-container').height(height);
          $('#map').height(height);
          if (typeof currMap !== 'undefined')
            currMap.invalidateSize();
        {% endif %}
      });

      /**
       * @function
       * @name filterMapFeatures
       *
       * filtert Layer (= Features) auf der Karte
       *
       * @param {Object[]} filterAttributesList - Liste für Filterobjekte
       * @param {Object} layer - Layer (= Feature)
       * @param {boolean} isSubLayer - Layer (= Feature) ist Bestandteil einer Layergruppe (= eines Clusters)?
       * @param {Object} [clusterLayer=layer] - Layergruppe (= Cluster), falls vorhanden; standardmäßig auf den Layer (= das Feature) gesetzt
       */
      function filterMapFeatures(filterAttributesList, layer, isSubLayer, clusterLayer = layer) {
        let stillVisible = true;
        for (let i = 0; i < filterAttributesList.length; i++) {
          // bei Stichtagsfilter einen entsprechenden Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
          if (filterAttributesList[i].name === 'deadline') {
            // auf passende Formatierung achten, das es sich beim Filter um einen Datumsfilter handelt!
            if (!(new Date(filterAttributesList[i].value) > new Date(layer.feature.properties['deadline_0'])) || !(new Date(layer.feature.properties['deadline_1']) > new Date(filterAttributesList[i].value)))
              stillVisible = false;
          // bei "linkem" Intervallfilter (also für niedrigere/kleinere/frühere Werte) einen "kleiner"-Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
          } else if (filterAttributesList[i].intervalside === 'left') {
            if (filterAttributesList[i].type === 'date') {
              // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
              if (new Date(filterAttributesList[i].value) > new Date(layer.feature.properties[filterAttributesList[i].name]))
                stillVisible = false;
            } else if (filterAttributesList[i].type === 'datetime') {
              // auf passende Formatierung achten, wenn es sich beim Filter um einen Zeitstempelfilter handelt!
              if (new Date(filterAttributesList[i].value).valueOf() > new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf())
                stillVisible = false;
            } else {
              if (filterAttributesList[i].value > layer.feature.properties[filterAttributesList[i].name])
                stillVisible = false;
            }
          // bei "rechtem" Intervallfilter (also für höhere/größere/spätere Werte) einen "größer"-Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
          } else if (filterAttributesList[i].intervalside === 'right') {
            if (filterAttributesList[i].type === 'date') {
              // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
              if (new Date(layer.feature.properties[filterAttributesList[i].name]) > new Date(filterAttributesList[i].value))
                stillVisible = false;
            } else if (filterAttributesList[i].type === 'datetime') {
              // auf passende Formatierung achten, wenn es sich beim Filter um einen Zeitstempelfilter handelt!
              if (new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf() > new Date(filterAttributesList[i].value).valueOf())
                stillVisible = false;
            } else {
              if (layer.feature.properties[filterAttributesList[i].name] > filterAttributesList[i].value)
                stillVisible = false;
            }
          // bei Checkboxen-Sets String-Vergleich mit allen aktivierten Checkboxen durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken, falls einzelne Checkboxen additiv wirken sollen
          } else if (filterAttributesList[i].type === 'checkbox-set' && filterAttributesList[i].value.length > 0) {
            if (filterAttributesList[i].filtertype === 'additive') {
              for (let j = 0; j < filterAttributesList[i].value.length; j++) {
                if (layer.feature.properties[filterAttributesList[i].name].toLowerCase().indexOf(filterAttributesList[i].value[j].toLowerCase()) === -1)
                  stillVisible = false;
              }
            } else {
              stillVisible = false;
              for (let k = 0; k < filterAttributesList[i].value.length; k++) {
                if (layer.feature.properties[filterAttributesList[i].name].toLowerCase().indexOf(filterAttributesList[i].value[k].toLowerCase()) !== -1) {
                  stillVisible = true;
                  break;
                }
              }
            }
          // ansonsten einen Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
          } else if (filterAttributesList[i].type !== 'checkbox-set') {
            if (filterAttributesList[i].type === 'date' || filterAttributesList[i].type === 'datetime') {
              // negative oder positive Wirkungslogik?
              if (filterAttributesList[i].logic === 'negative') {
                // auf passende Formatierung achten, wenn es sich beim Filter um einen Datums- oder Zeitstempelfilter handelt!
                if (new Date(filterAttributesList[i].value).valueOf() === new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf())
                  stillVisible = false;
              } else {
                // auf passende Formatierung achten, wenn es sich beim Filter um einen Datums- oder Zeitstempelfilter handelt!
                if (new Date(filterAttributesList[i].value).valueOf() !== new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf())
                  stillVisible = false;
              }
            } else if (filterAttributesList[i].type === 'list') {
              // negative oder positive Wirkungslogik?
              if (filterAttributesList[i].logic === 'negative') {
                if (layer.feature.properties[filterAttributesList[i].name].toLowerCase() === filterAttributesList[i].value.toLowerCase())
                  stillVisible = false;
              } else {
                if (layer.feature.properties[filterAttributesList[i].name].toLowerCase() !== filterAttributesList[i].value.toLowerCase())
                  stillVisible = false;
              }
            } else {
              // negative oder positive Wirkungslogik?
              if (filterAttributesList[i].logic === 'negative') {
                if (layer.feature.properties[filterAttributesList[i].name].toLowerCase().indexOf(filterAttributesList[i].value.toLowerCase()) !== -1)
                  stillVisible = false;
              } else {
                if (layer.feature.properties[filterAttributesList[i].name].toLowerCase().indexOf(filterAttributesList[i].value.toLowerCase()) === -1)
                  stillVisible = false;
              }
            }
          }
        }
        // falls Layer (= Feature) nicht zur Ausblendung vorgemerkt ist, also weiterhin sichtbar sein soll:
        if (stillVisible) {
          // Variable für Primärschlüssel der aktuellen Filtermenge aktualisieren
          window.currentFilterPrimaryKeys.push(layer.feature.properties['{{ model_pk_field }}']);
          // Variable für Bounding-Box der aktuellen Filtermenge aktualisieren
          let north = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lat : layer.getBounds().getNorth());
          let east = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lng : layer.getBounds().getEast());
          let south = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lat : layer.getBounds().getSouth());
          let west = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lng : layer.getBounds().getWest());
          if (window.currentFilterExtent.length === 0) {
            window.currentFilterExtent[0] = [];
            window.currentFilterExtent[0][0] = north;
            window.currentFilterExtent[0][1] = east;
            window.currentFilterExtent[1] = [];
            window.currentFilterExtent[1][0] = south;
            window.currentFilterExtent[1][1] = west;
          } else {
            if (window.currentFilterExtent[0][0] > north)
              window.currentFilterExtent[0][0] = north;
            if (window.currentFilterExtent[0][1] > east)
              window.currentFilterExtent[0][1] = east;
            if (window.currentFilterExtent[1][0] < south)
              window.currentFilterExtent[1][0] = south;
            if (window.currentFilterExtent[1][1] < west)
              window.currentFilterExtent[1][1] = west;
          }
          // Layer (= Feature) einblenden, falls es von initialer Feature-Ausblendung betroffen ist
          {% if map_filter_hide_initial %}
            if (typeof layer.feature.properties.hide_initial !== 'undefined' && layer.feature.properties.hide_initial) {
              layer.setStyle({
                color: '#3388ff',
                fill: true,
                fillColor: '#3388ff',
                stroke: true,
                opacity: 1
              });
            }
          {% endif %}
        // ansonsten:
        } else {
          // Layer (= Feature) tatsächlich ausblenden
          if (isSubLayer) {
            window.removedLayers.push(layer);
            clusterLayer.removeLayer(layer);
          } else
            layer.getElement().style.display = 'none';
        }
      }

      /**
       * @function
       * @name showAllMapFeatures
       *
       * zeigt alle Layers (= Features) auf der Karte (wieder) an
       */
      function showAllMapFeatures() {
        currMap.eachLayer(function(layer) {
          if (layer.feature) {
            layer.getElement().style.display = '';
            // Layer (= Feature) ausblenden, falls es von initialer Feature-Ausblendung betroffen ist
            {% if map_filter_hide_initial %}
              if (typeof layer.feature.properties.hide_initial !== 'undefined' && layer.feature.properties.hide_initial) {
                layer.setStyle({
                  fill: false,
                  stroke: false,
                  opacity: 0
                });
              }
            {% endif %}
          } else if (layer.id === 'cluster') {
            layer.addLayers(window.removedLayers);
            layer.refreshClusters();
          }
        });
        window.removedLayers = [];
      }

      /**
       * @function
       * @name applyFilters
       *
       * wendet Filter an
       *
       * @param {Object[]} filterAttributesList - Liste für Filterobjekte
       */
      function applyFilters(filterAttributesList) {
        if (filterAttributesList.length > 0) {
          showAllMapFeatures();
          window.currMap.eachLayer(function(layer) {
            if (layer.feature) {
              filterMapFeatures(filterAttributesList, layer, false);
            } else if (layer.id === 'cluster') {
              let clusterLayer = layer;
              layer.eachLayer(function(subLayer) {
                filterMapFeatures(filterAttributesList, subLayer, true, clusterLayer);
              });
              layer.refreshClusters();
            }
          });
        } else {
          showAllMapFeatures();
        }
      }
    </script>
  {% endif %}
{% endblock %}
