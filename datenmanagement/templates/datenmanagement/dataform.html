{% extends "_base/navbar.html" %}
{% load datenmanagement_tags %}
{% load guardian_tags %}
{% load leaflet_tags %}
{% load static %}

{% block title %}Formular | {% endblock %}

{% block style %}
  {{ block.super }}
  {% leaflet_css plugins="geoman" %}
  <link rel="stylesheet" type="text/css" href="{% static 'leaflet-locatecontrol-0.76.1/L.Control.Locate.min.css' %}"/>
  <link rel="stylesheet" type="text/css" href="{% static 'tempusdominus-bootstrap-4-5.39.0/tempusdominus-bootstrap-4.min.css' %}" />
  <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/dataform.css' %}" />
  {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/dataform-mobile.css' %}" />
  {% else %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/dataform-desktop.css' %}" />
  {% endif %}
{% endblock %}

{% block scripts %}
  {{ block.super }}
  {% leaflet_js plugins="geoman" %}
  <script type="text/javascript" src="{% static 'proj4js-2.8.0/proj4.js' %}"></script>
  <script type="text/javascript" src="{% static 'wicket-1.3.8/wicket.js' %}"></script>
  <script type="text/javascript" src="{% static 'wicket-1.3.8/wicket-leaflet.js' %}"></script>
  <script type="text/javascript" src="{% static 'proj4leaflet-1.0.2/proj4leaflet.js' %}"></script>
  <script type="text/javascript" src="{% static 'leaflet-locatecontrol-0.76.1/L.Control.Locate.min.js' %}"></script>
  <script type="text/javascript" src="{% static 'moment-2.29.4/moment-with-locales.min.js' %}"></script>
  <script type="text/javascript" src="{% static 'tempusdominus-bootstrap-4-5.39.0/tempusdominus-bootstrap-4.min.js' %}"></script>
  <script type="text/javascript" src="{% static 'tempusdominus-bootstrap-4-5.39.0/tempusdominus-de.js' %}"></script>
  <script type="module" src="{% static 'node_modules/martinez-polygon-clipping/dist/martinez.min.js' %}"></script>
  <script type="module" src="{% static 'helpers/leafletHelpers.js' %}"></script>
  <script type="text/javascript" src="{% static 'helpers/generics.js' %}"></script>
{% endblock %}

{% block content %}
  {% if form.errors %}
    {% for field in form %}
      {% if field.errors %}
        {% for error in field.errors %}
          <div class="alert alert-danger" role="alert">
            {% autoescape off %}
              {{ error }}
            {% endautoescape %}
          </div>
        {% endfor %}
      {% endif %}
    {% endfor %}
    {% if form.non_field_errors %}
      {% for error in form.non_field_errors %}
        <div class="alert alert-danger" role="alert">
          {{ error|customize_error_message }}
        </div>
      {% endfor %}
    {% endif %}
    <div class="mb-4"></div>
  {% endif %}
  {% if associated_new %}
    <div class="alert alert-primary" role="alert">
      <h5 class="alert-heading">assoziierte Datensätze</h5>
      {% if object and associated_objects %}
        <ul>
          {% for associated_object in associated_objects %}
            <li>{{ associated_object.title }} {{ associated_object.name }} <a href="{{ associated_object.link }}" target="_blank" title="{{ associated_object.title }} ansehen oder bearbeiten"><i class="fas fa-arrow-up-right-from-square"></i></a></li>{% if associated_object.preview_img_url %} <a href="{{ associated_object.preview_img_url }}" target="_blank" title="große Ansicht öffnen…"><img src="{% if associated_object.preview_thumb_url %}{{ associated_object.preview_thumb_url }}{% else %}{{ associated_object.preview_img_url }}{% endif %}" alt="Vorschau" width="50px" /></a>{% endif %}
          {% endfor %}
        </ul>
      {% else %}
        (noch) keine assoziierten Datensätze vorhanden
      {% endif %}
      {% if user|user_has_object_change_permission:object %}
        <hr/>
        {% for associated_new_entry in associated_new %}
          <p class="{% if forloop.last %}mb-1{% else %}mb-3{% endif %}">
            <a class="btn btn-primary" role="button" href="{{ associated_new_entry.link }}" target="_blank"><i class="fas fa-arrow-up-right-from-square"></i> {{ associated_new_entry.title }} anlegen</a>
          </p>
        {% endfor %}
      {% endif %}
    </div>
    <div class="mb-4"></div>
  {% endif %}
	<form class="form" role="form" method="post" enctype="multipart/form-data" action="">
  {% csrf_token %}
    <div {% if geometry_type %}id="custom-form"{% endif %}>
      <table class="table table-striped">
        {% for field in form %}
          {% if not field|is_field_address_related_field and not field|is_field_geometry_field %}
            <tr>
              <td>
                {% if field|is_field_hours_related_field %}
                  {{ field.label_tag }} <small>(<a href="{% static 'hilfe/work/datensatz-anlegen.html' %}#datensatz-anlegen-oeffnungszeiten"><i class="fas fa-question-circle"></i> Hilfe</a>)</small>
                {% elif fields_with_foreign_key_to_linkify and field.name in fields_with_foreign_key_to_linkify %}
                  {% if object and user|user_has_object_change_permission:object %}
                    {% with foreign_model=object|get_value_of_field:field.name|get_class_name %}
                      {{ field.label_tag }} <a href="{% url 'datenmanagement:'|add:foreign_model|add:'change' field.value %}" id="link_{{ field.name }}"> <i class="fas fa-arrow-up-right-from-square" title="{{ field.label }} ansehen oder bearbeiten"></i></a>
                    {% endwith %}
                  {% else %}
                    {% with foreign_model=field.name|get_foreign_key_field_class_name:model_name %}
                      {{ field.label_tag }} <a hidden href="{% url 'datenmanagement:'|add:foreign_model|add:'change' '' %}" id="link_{{ field.name }}"> <i class="fas fa-arrow-up-right-from-square" title="{{ field.label }} ansehen oder bearbeiten"></i></a>
                    {% endwith %}
                  {% endif %}
                {% else %}
                  {{ field.label_tag }}
                {% endif %}
              </td> 
              {% autoescape off %}
                <td>
                  {{ field }}
                </td>
              {% endautoescape %}
            </tr>
          {% endif %}
        {% endfor %}
        {% if gpx_input %}
          <tr>
            <td>
              <label for="id_gpx" class="required">GPX-Datei</label>
            </td>
            <td>
              <div class="custom-file">
                <input class="form-control" type="file" id="id_gpx" name="gpx" accept=".gpx">
              </div>
            </td>
          </tr>
        {% endif %}
      </table>
    </div>
    {% if geometry_type %}
      <div id="map-adresssearch-container-form">
        {% if geometry %}
          <textarea hidden id="id_geometrie" class="required django-leaflet-raw-textarea" name="geometrie" cols="150" rows="4">{{ geometry }}</textarea>
        {% else %}
          <textarea hidden id="id_geometrie" class="required django-leaflet-raw-textarea" name="geometrie" cols="150" rows="4">{ "type": "{{ geometry_type }}", "coordinates": [] }</textarea>
        {% endif %}
        {% leaflet_map "id_geometrie-map" callback="id_geometrie_map_callback" %}
        {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_object_change_permission:object %}
          {% if geometry_type == 'Point' or address_type and not address_mandatory %}
            <div class="d-grid mt-3 gap-2 d-md-block">
              {% if geometry_type == 'Point' %}
                <button disabled id="addressToMap" class="btn btn-success" type="button"><i class="fas fa-location-dot"></i> Marker setzen</button>
              {% endif %}
              {% if not address_mandatory %}
                {% if address_type == 'Adresse' %}
                  <button disabled id="mapToAddress" class="btn btn-success" type="button"><i class="fas fa-house"></i> Adresse übernehmen</button>
                {% elif address_type == 'Straße' %}
                  <button disabled id="mapToStreet" class="btn btn-success" type="button"><i class="fas fa-road"></i> Straße übernehmen</button>
                {% endif %}
              {% endif %}
            </div>
          {% endif %}
        {% endif %}
        <div class="mt-3 mb-5">
          {% if address_type %}
            {% if address_type == 'Adresse' %}
              <label for="id_adresse" class="form-label">Adresse</label>
              <div class="form-floating">
                {{ form.adresse }}
                <label for="id_adresse">Adresse eingeben…</label>
              </div>
              <input id="id_adresse_uuid" type="hidden" name="adresse_uuid" value="{% if current_address %}{{ current_address }}{% endif %}">
            {% elif address_type == 'Straße' %}
              <label for="id_strasse" class="form-label">Straße</label>
              <div class="form-floating">
                {{ form.strasse }}
                <label for="id_strasse">Straße eingeben…</label>
              </div>
              <input id="id_strasse_uuid" type="hidden" name="strasse_uuid" value="{% if current_street %}{{ current_street }}{% endif %}">
            {% endif %}
          {% else %}
            {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_object_change_permission:object %}
              <label for="id_address_search" class="form-label">Adressensuche</label>
              <div class="form-floating">
                <input id="id_address_search" type="text" class="form-control" name="address_search" autocapitalize="off" autocomplete="off" placeholder="Adresse, Straße oder Gemeindeteil eingeben…">
                <label for="id_address_search">Adresse, Straße oder Gemeindeteil eingeben…</label>
              </div>
            {% endif %}
          {% endif %}
          <div id="results-container" class="results"></div>
        </div>        
      </div>
    {% endif %}
    <div id="buttons">
      <div class="d-grid mt-5 mb-3 gap-2 d-md-block">
        {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_object_change_permission:object %}
          <button class="btn btn-success" type="submit" onclick="setAddressUuid();"><i class="fas fa-floppy-disk"></i> speichern</button>
        {% endif %}
        {% if object and user|user_has_model_delete_permission:model_name_lower and user|user_has_object_delete_permission:object %}
          <a class="btn btn-danger" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'delete' object.pk %}"><i class="fas fa-trash"></i> löschen</a>
        {% endif %}
        <a class="btn btn-warning" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'start' %}"><i class="fas fa-hand"></i> abbrechen</a>
      </div>
    </div>
    {% if address_type %}
      <div id="{% if address_type == 'Adresse' %}maptoaddress{% elif address_type == 'Straße' %}maptostreet{% endif %}-error-modal" class="modal fade" tabindex="-1" aria-labelledby="{% if address_type == 'Adresse' %}maptoaddress{% elif address_type == 'Straße' %}maptostreet{% endif %}-error-modal-label" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h5 id="{% if address_type == 'Adresse' %}maptoaddress{% elif address_type == 'Straße' %}maptostreet{% endif %}-error-modal-label" class="modal-title">Keine Zuordnung einer {{ address_type }} möglich</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              Objekt zu weit von nächster {{ address_type }} entfernt!
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-primary" data-bs-dismiss="modal">schließen</button>
            </div>
          </div>
        </div>
      </div>
    {% endif %}
    {% if gpx_input %}
      <div id="id_gpxLoading" class="modal fade" tabindex="-1">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header" id="id_gpxLoading-header">
              <h5 class="modal-title" id="id_gpxLoading-title">Auswerten der GPX-Datei</h5>
            </div>
            <div class="modal-body" id="id_gpxLoading-body">
              Die GPX-Datei wird zum Server hochgeladen und ausgewertet. Dies kann einen Moment dauern.
              <div class="text-center">
                <div class="spinner-border m-4" role="status">
                  <span class="sr-only">laden…</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    {% endif %}
	</form>
  <script type="text/javascript">
    // Date-/Time-/Date-Time-Picker
    $('.datetimepicker-input').datetimepicker();
    $('.datetimepicker-input').datetimepicker('icons', tempusdominusIcons);
    $('.datetimepicker-input').datetimepicker('buttons', tempusdominusButtons);
    $('.datetimepicker-input').datetimepicker('tooltips', tempusdominusTooltips);
    $('.input-group-append').each(function () {
        var that = $(this);
        var datetimepickerButton = $('<button></button>');
        datetimepickerButton.addClass('btn btn-outline-secondary');
        datetimepickerButton.attr('type', 'button');
        datetimepickerButton.attr('data-target', that.data('target'));
        datetimepickerButton.attr('data-toggle', that.data('toggle'));
        $(this).attr('data-target').includes('zeit') ? datetimepickerButton.html('<i class="fas fa-clock"></i>') : datetimepickerButton.html('<i class="fas fa-calendar"></i>');
        $(this).replaceWith(datetimepickerButton);
    });

    // globale Variablen
    let FEATURE_GEOMETRY = []; // wird in showResults() befüllt

    // Bunte Marker für Leaflet konfigurieren
    let blueMarker = new L.Icon({
        iconUrl: '{% static "datenmanagement/img/leaflet-markers/marker-blue.svg" %}',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });

      let greenMarker = new L.Icon({
        iconUrl: '{% static "datenmanagement/img/leaflet-markers/marker-green.svg" %}',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });

      let redMarker = new L.Icon({
        iconUrl: '{% static "datenmanagement/img/leaflet-markers/marker-red.svg" %}',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });

    function id_geometrie_map_callback(map, options) {
      // Karte auch in anderen JavaScript-Funktionen verfügbar machen
      window.currMap = map;

      // Standard-Zoom-Kontrollelemente entfernen und durch solche mit eigenen Tooltips ersetzen
      map.zoomControl.remove();
      L.control.zoom({
        zoomInTitle:'hineinzoomen',
        zoomOutTitle:'herauszoomen'
      }).addTo(map);

      {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
        // bei mobilen Geräten: Standortbestimmung hinzufügen
        var locationControl = L.control.locate({
          drawCircle: false,
          drawMarker: false,
          flyTo: true,
          locateOptions: {
            enableHighAccuracy: true
          },
          setView: 'untilPan',
          strings: {
            title: 'Standortbestimmung'
          }
        });
        locationControl.addTo(map);
      {% endif %}

      // Einige Konstanten und Variablen initialisieren und definieren
      map._wmsFormat = 'image/png';
      map._maxLayerZoom = 19;
      map._minLayerZoom = 13;
      map._themaUrl = {};

      // EPSG:25833 definieren
      proj4.defs([
        ['EPSG:25833', '+proj=utm +zone=33 +ellps=WGS84 +towgs84=0,0,0,0,0,0,1 +units=m +no_defs'],
      ]);

      /*
       * Leaflet-Geoman Konfigurationen
       */
       // eigene Übersetzungen definieren
      const customTranslation = {
        actions: {
          cancel: 'abbrechen',
          finish: 'beenden',
          removeLastVertex: 'letzten Stützpunkt löschen',
        },
        buttonTitles: {
          cutButton: 'Teile aus vorhandenen Kartenobjekten ausschneiden',
          deleteButton: 'vorhandene Kartenobjekte löschen',
          dragButton: 'vorhandene Kartenobjekte verschieben',
          drawLineButton: 'Linie zeichnen',
          drawMarkerButton: 'Marker (neu) setzen',
          editButton: 'vorhandene Kartenobjekte bearbeiten',
        },
        tooltips: {
          continueLine: 'klicken, um weiteren Stützpunkt zu setzen',
          finishLine: 'weitere Stützpunkte setzen oder auf beliebigen Stützpunkt klicken, um Linie abzuschließen',
          finishPoly: 'weitere Stützpunkte setzen oder auf ersten Stützpunkt klicken, um Polygon abzuschließen',
          finishRect: 'klicken, um Rechteck abzuschließen',
          firstVertex: 'klicken, um ersten Stützpunkt zu setzen',
          placeMarker: 'klicken, um Marker zu setzen',
        },
      };

      map.pm.setLang('customDe', customTranslation, 'de');   // Tooltip-Sprache mit eigenen Übersetzungen setzen

      map.pm.setPathOptions({
        color: 'red',               // Farbe für gezeichnete Objekte
        fillColor: 'red',           // Füllfarbe für gezeichnete Objekte
        requireSnapToFinish: true,  // Zeichnen von Polygonen endet mit bestehendem Punkt
        templineStyle: {
          color: 'red',             // Farbe während des zeichnens
        },
      });

      map.pm.setGlobalOptions({
        snapDistance: 10,
        continueDrawing: false,   // Nach Hinzufügen einer Geometrie
        markerStyle: {
          icon: redMarker,
        }
      })

      {% if geometry_type == 'Point' %}
        // Leaflet-Geoman controls zur Map hinzufügen
        map.pm.addControls({
          position: 'topleft',
          drawCircleMarker: false,  // Punktueller Kreis
          drawCircle: false,        // Kreis
          drawPolyline: false,      // Linie
          drawRectangle: false,     // Rechteck
          drawPolygon: false,       // Polygon
          drawText: false,          // Text
          dragMode: false,          // Verschieben deaktivieren
          editMode: false,          // Editieren des Punktes deaktivieren
          cutPolygon: false,        // Polygon aus anderer Geometrie ausschneiden
          rotateMode: false,        // Geometrie rotieren
          removalMode: false,       // Entfernen von Layern deaktivieren
        });
      {% elif 'LineString' in geometry_type and model_name != 'Fallwildsuchen_Nachweise' %}
        // Leaflet-Geoman controls zur Map hinzufügen
        map.pm.addControls({
          position: 'topleft',
          drawCircleMarker: false,  // Punktueller Kreis
          drawCircle: false,        // Kreis
          drawMarker: false,        // Marker
          drawRectangle: false,     // Rechteck
          drawPolygon: false,       // Polygon
          drawText: false,          // Text
          dragMode: false,          // Verschieben deaktivieren
          cutPolygon: false,        // Polygon aus anderer Geometrie ausschneiden
          rotateMode: false,        // Geometrie rotieren
        });
      {% elif geometry_type == 'Polygon' %}
        // Leaflet-Geoman controls zur Map hinzufügen
        map.pm.addControls({
          position: 'topleft',
          drawCircleMarker: false,  // Punktueller Kreis
          drawCircle: false,        // Kreis
          drawMarker: false,        // Marker
          drawPolyline: false,      // Linie
          drawText: false,          // Text
          dragMode: false,          // Verschieben deaktivieren
          cutPolygon: false,        // Polygon aus anderer Geometrie ausschneiden
          rotateMode: false,        // Geometrie rotieren
        });
      {% elif geometry_type == 'MultiPolygon' %}
        // Leaflet-Geoman controls zur Map hinzufügen
        map.pm.addControls({
          position: 'topleft',
          drawCircleMarker: false,  // Punktueller Kreis
          drawCircle: false,        // Kreis
          drawMarker: false,        // Marker
          drawPolyline: false,      // Linie
          drawText: false,          // Text
          dragMode: false,          // Verschieben deaktivieren
          rotateMode: false,        // Geometrie rotieren
        });
      {% else %}
        // Leaflet-Geoman controls zur Map hinzufügen
        map.pm.addControls({
          position: 'topleft',
          drawCircleMarker: false,  // Punktueller Kreis
          drawCircle: false,        // Kreis
          drawMarker: false,        // Marker
          drawPolyline: false,      // Linie
          drawRectangle: false,     // Rechteck
          drawPolygon: false,       // Polygon
          drawText: false,          // Text
          dragMode: false,          // Verschieben deaktivieren
          editMode: false,          // Editieren des Punktes deaktivieren
          cutPolygon: false,        // Polygon aus anderer Geometrie ausschneiden
          rotateMode: false,        // Geometrie rotieren
          removalMode: false,       // Entfernen von Layern deaktivieren
        });
      {% endif %}
      {% if 'Polygon' in geometry_type %}
        // adoptGeometry-Button bei Polygonen und MultiPolygonen hinzufügen
        map.pm.Toolbar.createCustomControl({
          name: 'adoptGeometry',
          title: 'vorhandene Geometrien adoptieren',
          block: 'edit',
          className: 'adopt-geometry-control',
          actions: [
            // default 'finish' action
            'finishMode',
          ],
        });
        map.on('pm:buttonclick', (e) => {
          // Geometrien Interaktive setzen
          if (e.btnName === 'adoptGeometry' && e.button.toggleStatus === false) {
            map.getLayersOfType(type = 'Polygon', withCompatible = true).forEach((layer) => {
              layer.setInteractive(true);
              layer.on('click', () => {
                let j = JSON.parse($('#id_geometrie').val());
                if (j.type.indexOf('MultiPolygon') > -1){
                  map.pm.getGeomanDrawLayers()[0].unite(layer, 'MultiPolygon');
                } else {
                  map.pm.getGeomanDrawLayers()[0].unite(layer, 'Polygon');
                }
              });
            });
          }
        });
        map.on('pm:buttonclick', (e) => {
          // Bearbeitung deaktivieren
          if (e.btnName === 'adoptGeometry' && e.button.toggleStatus === true){
            map.pm.getGeomanLayers().forEach((lay) => {
              lay.setInteractive(interactive=false);
            });
          }
        });
        map.on('pm:actionclick', (e) => {
          // Bearbeitung deaktivieren
          if (e.btnName === 'adoptGeometry' && e.text === 'beenden'){
            map.pm.getGeomanLayers().forEach((lay) => {
              lay.setInteractive(interactive=false);
            });
          }
        });
      {% endif %}

      /*
       * Definition der Hintergrundkarten
       */

      // Standard-Layer: ORKa.MV
      const orkamv =  L.tileLayer('https://www.orka-mv.de/geodienste/orkamv/tiles/1.0.0/orkamv/GLOBAL_WEBMERCATOR/{z}/{x}/{y}.png', {
        maxZoom: map._maxLayerZoom,
        attribution: 'Kartenbild © Hanse- und Universitätsstadt Rostock (<a href="http://creativecommons.org/licenses/by/4.0/deed.de" target="_blank">CC BY 4.0</a>)<br>Kartendaten © <a href="http://www.openstreetmap.org" target="_blank">OpenStreetMap</a> (<a href="http://opendatacommons.org/licenses/odbl" target="_blank">ODbL</a>) und LkKfS-MV'
      });

      // ORKa.MV standardmäßig zur Karte hinzufügen
      map.addLayer(orkamv);

      // OpenStreetMap
      const osm =  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: map._maxLayerZoom,
        attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap-Mitwirkende</a>'
      });

      // basemap.de
      const basemapde = L.tileLayer.wms('https://sgx.geodatenzentrum.de/wms_basemapde', {
        layers: 'de_basemapde_web_raster_farbe',
        format: map._wmsFormat,
        maxZoom: map._maxLayerZoom,
        attribution: '© GeoBasis-DE/BKG'
      });

      // Liegenschaftskarte
      const liegenschaftskarte = L.tileLayer.wms('{% url "datenmanagement:owsproxy" %}' + '/liegenschaftskarte/wms', {
        layers: 'hro.liegenschaftskarte',
        format: map._wmsFormat,
        maxZoom: map._maxLayerZoom,
        attribution: '© Hanse- und Universitätsstadt Rostock (MLV intern)'
      });

      // Luftbild
      const luftbild =  L.tileLayer('{% url "datenmanagement:owsproxy" %}' + '/luftbild_mv-20/tiles/1.0.0/hro.luftbild_mv-20.luftbild_mv-20/GLOBAL_WEBMERCATOR/{z}/{x}/{y}.png', {
        maxZoom: map._maxLayerZoom,
        attribution: '© GeoBasis-DE/M-V'
      });

      // Kilometerquadrate ETRS89/UTM-33N
      const kilometerquadrate = L.tileLayer.wms('https://geo.sv.rostock.de/geodienste/koordinatensysteme/wms', {
        layers: 'hro.koordinatensysteme.kilometerquadrate_utm',
        format: map._wmsFormat,
        maxZoom: map._maxLayerZoom,
        transparent: true
      });

      // definierte Karten als Hintergrundkarten zusammenfassen
      const baseMaps = {
        'basemap.de': basemapde,
        'Liegenschaftskarte': liegenschaftskarte,
        'Luftbild': luftbild,
        'OpenStreetMap': osm,
        'ORKa.MV': orkamv
      };

      // definierte Karten als Overlay-Karten zusammenfassen
      let overlayMaps = {
        'Kilometerquadrate ETRS89/UTM-33N': kilometerquadrate
      };


      /*
       * zusätzliche WMS-Layer definieren und als Overlay-Karten hinzufügen
       */
      {% if additional_wms_layers %}
        {% for additional_wms_layer in additional_wms_layers %}
          let overlayMap = L.tileLayer.wms('{{ additional_wms_layer.url }}', {
            layers: '{{ additional_wms_layer.layers }}',
            format: map._wmsFormat,
            maxZoom: map._maxLayerZoom,
            transparent: true
          });
          overlayMaps['{{ additional_wms_layer.title }}'] = overlayMap;
        {% endfor %}
      {% endif %}

      // Control-Menü für Hintergrundkarten zur Map hinzufügen
      L.control.layers(baseMaps,overlayMaps).addTo(map);


      /*
       * Im Change View Geometrie auf Karte anzeigen
       */
      {% if geometry %}
        map.loadGeometryFromField('#id_geometrie')
      {% endif %}


      {% if model_name != 'Fallwildsuchen_Nachweise' %}
        /*
         * Zusätzliche Datenthemen anbieten
         */

        // Füge zweiten Layer-Control Button ein zum Anzeigen von Datensätzen
        let dataLayerControl = new L.control.layers({}, {}).addTo(map);

        // iteriere durch alle Datenthemen
        {% for key, value in model_list.items %}
          {% with datenthema_name_lower=key|lower %}
            map._themaUrl = {...map._themaUrl, '{{ value }}': '{% url 'datenmanagement:'|add:key|add:'geometry' %}'};
            // GeoJson-Projektions-Layer initialisieren
            let {{ datenthema_name_lower }} = new L.Proj.geoJson();
            // leeres GeoJson-Projektions-Layer zur Layercontrol hinzufügen
            dataLayerControl.addOverlay({{ datenthema_name_lower }}, '{{ value }}');
            // Beim hinzufügen des Layers Daten laden
            {{ datenthema_name_lower }}.on('add', function () {
              if (map.getZoom() > map._minLayerZoom) {
                // Daten zum entsprechenden Layer hinzufügen
                map.loadExternalData(
                  '{% url 'datenmanagement:'|add:key|add:'geometry' %}',
                  this
                );

                map.eachLayer((layer) => {
                  // 'Anheben' des Layers, welches bearbeitet wird
                  if (layer._drawnByGeoman === true){
                    if (layer instanceof L.Marker){
                      layer.setZIndexOffset(1000);
                    } else {
                      layer.bringToFront();
                    }
                  }
                });
              }
            });
          {% endwith %}
        {% endfor %}


        /*
         * Beim Bewegen der Karte updateMap() ausführen
         */
        map.on('moveend', () => {
          map.updateMap(dataLayerControl);
        });
        map.on('zoomend', () => {
          map.updateMap(dataLayerControl);
        })
      {% endif %}


      /**
       * @function
       *
       * Beim Start des Modus 'Zeichnen' überprüfen, ob es bereits Geoman-Layer gibt.
       * Falls ja, lösche diese.
       *
       * @param e
       */
      map.on('pm:drawstart', function(e) {
        {% if geometry_type == 'Point' or geometry_type == 'LineString' or geometry_type == 'Polygon' %}
          if (map.pm.getGeomanLayers().length > 0){
            map.pm.getGeomanLayers().forEach((item) => {
              if (item._drawnByGeoman === true){
                map.removeLayer(item);
              }
            })
          }
        {% endif %}
      });


      {% if address_type %}
        /**
         * Wenn Datenmodell Adressbezug vorsieht und dies ein Pflichangabe ist, wird
         * beim Hinzufügen oder Editieren einer Geometrie die Addresse gesetzt.
         *
         * @param layer
         */
        map.on('pm:create', function ({layer}) {
          {% if address_mandatory %}
            // Adressenbezug setzen für gesetze Geometrie
            setAddressOrStreet('{{ address_type }}', layer);
            {% if geometry_type == "Point" %}
              // Bei Bewegungs-Event (nur bei Markern) setze Adresse neu
              layer.on('pm:dragend', (e) => {
                setAddressOrStreet('{{ address_type }}', e.layer);
              });
            {% else %}
              // Bei Bewegungs-Event (nur bei Markern) setze Adresse neu
              layer.on('pm:update', (e) => {
                setAddressOrStreet('{{ address_type }}', e.layer);
              });
            {% endif %}
          {% else %}
            $('#addressToMap').prop('disabled', false);
            $('#mapToAddress').prop('disabled', false);
            $('#mapToStreet').prop('disabled', false);
          {% endif %}
        });
      {% endif %}
    }


    $(document).ready(function() {
      // falls Gruppe von Benutzern gesetzt ist, die für das Feld Ansprechpartner/Bearbeiter in einer entsprechenden Auswahlliste genutzt werden sollen:
      // Auswahlfeld Ansprechpartner/Bearbeiter in normales Feld umwandeln...
      {% if group_with_users_for_choice_field %}
        // ...falls Benutzer kein Änderungsrecht am Datensatz hat
        {% if not user|user_has_object_delete_permission:object %}
          {% for field in form %}
            {% if field.name == 'ansprechpartner' or field.name == 'bearbeiter' %}
              let value = '';
              {% if field.name == 'ansprechpartner' %}
                value = '{{ object.ansprechpartner }}';
              {% endif %}
              {% if field.name == 'bearbeiter' %}
                value = '{{ object.bearbeiter }}';
              {% endif %}
              var inputField = $('<input>').attr({
                id: 'id_' + '{{ field.name }}',
                type: 'text',
                name: '{{ field.name }}',
                value: value
              });
              $('select#id_' + '{{ field.name }}').replaceWith(inputField);
            {% endif %}
          {% endfor %}
        {% endif %}
      {% endif %}

      // Checkboxen in Multiple-Choice-Feldern an Bootstrap 5 anpassen
      $('ul input[type="checkbox"]').each(function () {
          $(this).addClass('form-check-input');
      });


      // Read-only-Felder behandeln
      {% if readonly_fields %}
        {% for field in readonly_fields %}
          var inputField = $('input#id_' + '{{ field }}');
          {% if user|user_has_object_change_permission:object %}
            if (!inputField.val()) {
              inputField.closest('tr').hide();
            } else {
              inputField.parent().append('<span id="' + inputField.attr('id') + '" title="nicht editierbar – automatisch vergeben"><em>' + inputField.val() + '</em></span>');
              let label = inputField.parent().closest('tr').find('label');
              label.wrapInner('<em></em>');
              inputField.hide();
              if ($('div*[data-target="#id_{{ field }}"]'))
                $('div*[data-target="#id_{{ field }}"]').hide();
            }
           {% else %}
            inputField.closest('tr').hide();
           {% endif %}
        {% endfor %}
      {% endif %}

      // alle Felder deaktivieren, falls Benutzer kein Änderungsrecht am Datensatz hat
      {% if not user|user_has_object_change_permission:object %}
        $('button[data-toggle="datetimepicker"]').each(function () {
            $(this).prop('disabled', true);
        });
        $('input').each(function () {
            $(this).prop('disabled', true);
        });
        $('select').each(function () {
            $(this).prop('disabled', true);
        });
        $('textarea').each(function () {
            $(this).prop('disabled', true);
        });
      {% endif %}

      // Multi-Datei-Feld behandeln
      let fotoField = $('input#id_foto');
      if (fotoField.length) {
        fotoField.attr('accept', 'image/*');
        {% if multi_foto_field %}
          if (fotoField[0].files.length === 0) {
            fotoField.attr('multiple', 'multiple');
          }
        {% endif %}
      }

      let pdfField = $('input#id_pdf');
      if (pdfField.length) {
        pdfField.attr('accept', 'application/pdf');
      }

      // Adressensuche initialisieren

      results = $('div.results');
      {% if address_type %}
        {% if address_type == 'Adresse' %}
          let searchField = $('#id_adresse');
        {% elif address_type == 'Straße' %}
          searchField = $('#id_strasse');
        {% endif %}
      {% else %}
        searchField = $('#id_address_search');
      {% endif %}

      results.click(function(event) {
        $('html').one('click',function() {
          results.children().remove();
          results.fadeOut();
        });
        event.stopPropagation();
      });

      searchField.keyup(function() {
        if ($(this).val().length >= 3) {
          let searchText = searchField.val();
          $.ajax({
            url: '{% url "datenmanagement:addresssearch" %}',
            dataType: 'json',
            data: {
              query: searchText
            },
            success: showResults
          });
        } else {
          results.children().remove();
          results.fadeOut();
        }
      });

      {% if address_type %}
        {% if address_type == 'Adresse' %}
          $('#id_adresse').on('click', function() {
            $(this).val('');
            $('#id_adresse_uuid').val('');
            $('#results-container').hide();
          })
        {% elif address_type == 'Straße' %}
          $('#id_strasse').on('click', function() {
            $(this).val('');
            $('#id_strasse_uuid').val('');
            $('#results-container').hide();
          })
        {% endif %}
      {% else %}
        $('#id_address_search').on('click', function() {
          $(this).val('');
          $('#results-container').hide();
        });
      {% endif %}

      // Butten: 'Marker setzen'
      $('#addressToMap').on('click', function() {
        getAddress(window.currMap);
        $('#mapToAddress').prop('disabled', false);
        $('#mapToStreet').prop('disabled', false);
      });

      // Button: 'Adresse setzen'
      $('#mapToAddress').on('click', function() {
        setAddressOrStreet('{{ address_type }}', window.currMap.pm.getGeomanLayers()[0]);
        $('#addressToMap').prop('disabled', false);
      });

      // Button: 'Straße setzen'
      $('#mapToStreet').on('click', function() {
        setAddressOrStreet('{{ address_type }}', window.currMap.pm.getGeomanLayers()[0]);
        $('#addressToMap').prop('disabled', false);
      });

      // verhindern, dass HTML5-/jQuery-Fehlermeldungen bei Pflichtfeldern die Django-Fehlermeldungen überdecken
      $('[required]').removeAttr('required');

      // vertikale Position der Buttons dynamisch setzen anhand von Position und Größe des Formulars (plus „Puffer“ von 20 Pixeln)
      {% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %}
        let top = $('#custom-form').position().top + $('#custom-form').height() + 20;
        $('#buttons').offset({
          top: top
        });
      {% endif %}

      // Labels für verpflichtende Boolean-Felder anpassen
      $('input[type="checkbox"]:not([value])').parent().parent().find('label').addClass('required');

      // Fremdschlüssellinks dynamisch anpassen je nach aktueller Auswahl in entsprechenden Auswahlfeldern (bei leerer Auswahl Link verstecken)
      {% if fields_with_foreign_key_to_linkify and user|user_has_object_change_permission:object or not object %}
        {% for field in fields_with_foreign_key_to_linkify %}
          $('select#id_' + '{{ field }}').each(function () {
            $(this).on('change', function() {
              let link = $('a#link_' + '{{ field }}');
              let href = link.prop('href');
              let value = $(this).find(':selected').val();
              if (value) {
                href = href.replace(/\/change\/.*/, '/change/' + value + '/');
                link.prop('href', href);
                link.prop('hidden', false);
              } else {
                link.prop('hidden', true);
              }
            });
          });
        {% endfor %}
      {% endif %}

      // Links auf vorhandene Fotos, PDF etc. immer in neuem Tab öffnen
      $('td').find('a').attr('title', 'in neuem Tab öffnen…');
      $('td').find('a').attr('target', '_blank');

      // Links auf vorhandene Fotos, PDF etc. sowie entsprechende Upload-Buttons mit ordentlichem Text versehen
      $('td').find('a').parent().contents().filter(function () {
        return this.nodeType == 3
      }).remove();
      $('td').find('a').parent().find('input[type="file"]').before('ändern in: ');
      $('<br />').insertBefore($('input[type="checkbox"][name$="-clear"]'));
      $('label[for$="-clear_id"]').addClass('label-with-margin');
      $('label[for$="-clear_id"]').text('löschen');

      // bestimmte Werte in Auswahllisten mit Kleinbuchstaben versehen
      $('td').find('option').each(function () {
        if ($(this).text() === 'Unbekannt')
          $(this).text('unbekannt');
        else if ($(this).text() === 'Ja')
          $(this).text('ja');
        else if ($(this).text() === 'Nein')
          $(this).text('nein');
      });
    });


    /**
     * Marker auf Adresse oder Straße aus Adressfeld setzen
     *
     * @param map - Leaflet Karte
     */
    function getAddress(map) {
      let x = 0;
      let y = 0;
      if (map.pm.getGeomanLayers().length > 0){
        let layer = map.pm.getGeomanLayers()[0];
        if (layer._drawnByGeoman && layer._latlng) {
          if (FEATURE_GEOMETRY.type === 'Point') {
            x = FEATURE_GEOMETRY.coordinates[0];
            y = FEATURE_GEOMETRY.coordinates[1];
          } else {
            x = FEATURE_GEOMETRY.coordinates[0][1][0] + ((FEATURE_GEOMETRY.coordinates[0][0][0] - FEATURE_GEOMETRY.coordinates[0][1][0]) / 2);
            y = FEATURE_GEOMETRY.coordinates[0][0][1] + ((FEATURE_GEOMETRY.coordinates[0][2][1] - FEATURE_GEOMETRY.coordinates[0][0][1]) / 2);
          }
          layer.setLatLng([y, x]);
        }
      } else {
        {% if geometry_type == "Point" %}
          if (FEATURE_GEOMETRY.type === 'Point') {
            x = FEATURE_GEOMETRY.coordinates[0];
            y = FEATURE_GEOMETRY.coordinates[1];
          } else {
            x = FEATURE_GEOMETRY.coordinates[0][1][0] + ((FEATURE_GEOMETRY.coordinates[0][0][0] - FEATURE_GEOMETRY.coordinates[0][1][0]) / 2);
            y = FEATURE_GEOMETRY.coordinates[0][0][1] + ((FEATURE_GEOMETRY.coordinates[0][2][1] - FEATURE_GEOMETRY.coordinates[0][0][1]) / 2);
          }
          let layer = new L.Marker([y, x],{icon: redMarker,});
          layer._drawnByGeoman = true; 
          layer.addTo(window.currMap); 
        {% endif %}
      }
    }


    /**
     * Übernimmt Adresse aus Koordinaten eines Layers
     *
     * @param type - Typ
     * @param {layer} layer - Layer
     */
    function setAddressOrStreet(type, layer) {
      let json = layer.toGeoJSON();
      let xArray = [];
      let yArray = [];
      let ort = [];
      {% if 'point' in geometry_type|lower %}
        ort = json.geometry.coordinates;
      {% elif 'line' in geometry_type|lower %}
        Array.min = function( array ){
          return Math.min.apply( Math, array );
        };
        Array.max = function( array ){
          return Math.max.apply( Math, array );
        };
        $.each(json.geometry.coordinates, function(index, value) {
          xArray.push(json.geometry.coordinates[index][0]);
          yArray.push(json.geometry.coordinates[index][1]);
        });
        ort[0] = Array.min(xArray) + ((Array.max(xArray) - Array.min(xArray)) / 2);
        ort[1] = Array.min(yArray) + ((Array.max(yArray) - Array.min(yArray)) / 2);
      {% elif 'polygon' in geometry_type|lower %}
        Array.min = function( array ){
          return Math.min.apply( Math, array );
        };
        Array.max = function( array ){
          return Math.max.apply( Math, array );
        };
        $.each(json.geometry.coordinates, function(index_outer, value_outer) {
          $.each(json.geometry.coordinates[index_outer], function(index_inner, value_inner) {
            xArray.push(json.geometry.coordinates[index_outer][index_inner][0]);
            yArray.push(json.geometry.coordinates[index_outer][index_inner][1]);
          });
        });
        ort[0] = Array.min(xArray) + ((Array.max(xArray) - Array.min(xArray)) / 2);
        ort[1] = Array.min(yArray) + ((Array.max(yArray) - Array.min(yArray)) / 2);
      {% endif %}

      $.ajax({
        url: '{% url "datenmanagement:reversesearch" %}',
        dataType: 'json',
        data: {
          x: ort[0],
          y: ort[1],
        },
        success: function(data) {
          if (ort[0] != 0 && ort[1] != 0) {
            adoptResult(data, type);
          }
        }
      });
    }


    /**
     *
     *
     *  @param {JSON} json -
     *  @param {string} type -
     */
    function adoptResult(json, type) {
      let erfolg = false;
      if (type === 'Straße') {
        jQuery.each(json.features, function(index, item) {
          if (item.properties.objektgruppe === 'Straße') {
            let text = item.properties._title_.substring(item.properties._title_.lastIndexOf(', ') + 2);
            if (item.properties.gemeindeteil_abkuerzung)
              text += ' (' + item.properties.gemeindeteil_abkuerzung + ')';
            $('#id_strasse').val(text);
            $('#id_strasse_uuid').val(item.properties.uuid);
            erfolg = true;
            return false;
          }
        });
        if (erfolg === false) {
          var modal = new bootstrap.Modal($('#maptostreet-error-modal'));
          modal.show();
        }
      } else if (type === 'Adresse') {
        jQuery.each(json.features, function(index, item) {
          if (item.properties.objektgruppe === 'Adresse') {
            let text = item.properties._title_.substring(item.properties._title_.lastIndexOf(', ') + 2);
            if (item.properties.gemeindeteil_abkuerzung)
              text += ' (' + item.properties.gemeindeteil_abkuerzung + ')';
            $('#id_adresse').val(text);
            $('#id_adresse_uuid').val(item.properties.uuid);
            erfolg = true;
            return false;
          }
        });
        if (erfolg === false) {
          var modal = new bootstrap.Modal($('#maptoaddress-error-modal'));
          modal.show();
        }
      }
    }


    /**
     * Anzeigen der Ergebnisse der Adresssuche
     *
     * @param json - Ergebnisse als Json
     */
    function showResults(json) {
      results.children().remove();  // alte Ergebnisse entfernen

      // JSON durchgehen und je Feature ein Resultat bauen
      jQuery.each(json.features, function(index, item) {
        // falls Feature nicht historisch ist:
        if (!item.properties.historisch) {
          let titel = '';
          if (item.properties._title_.indexOf(', ') != -1)
            titel = item.properties._title_.substring(item.properties._title_.lastIndexOf(', ') + 2);
          else
            titel = item.properties._title_;
          // falls Datenmodell Adressenbezug vorsieht:
          {% if address_type %}
            // nur Objektgruppen berücksichtigen, die mit dem Typ des Adressenbezugs übereinstimmen
            let substring = item.properties.objektgruppe;
            if (item.properties.objektgruppe.indexOf(' HRO') != -1)
              substring = item.properties.objektgruppe.substring(0, item.properties.objektgruppe.lastIndexOf(' HRO'));
            if (substring === '{{ address_type }}') {
              let result = '<div class="result-element" data-feature="' + index + '" data-uuid="' + item.properties.uuid + '"><strong>' + titel + '</strong>';
              if (item.properties.gemeindeteil_abkuerzung)
                result += ' <small>(' + item.properties.gemeindeteil_abkuerzung + ')</small>';
              result += '</div>';
              results.append(result);
            }
          // ansonsten: alle Objektgruppen anzeigen
          {% else %}
            let result = '<div class="result-element" data-feature="' + index + '" data-uuid="' + item.properties.uuid + '"><strong>' + titel + '</strong>';
            if (item.properties.gemeindeteil_abkuerzung)
              result += ' <small>(' + item.properties.gemeindeteil_abkuerzung + ')</small>';
            result += '<small class="text-muted"><em>' + item.properties.objektgruppe.replace(/ HRO/, ''); + '</em></small></div>';
            results.append(result);
          {% endif %}
        }
      });

      // Resultate einblenden
      results.fadeIn();

      // bei Klick auf Resultat Karte auf dieses zoomen
      results.children().on('click', function() {
        $('#addressToMap').prop('disabled', false);
        {% if address_type %}
          var text = $(this).children('strong').text();
          if ($(this).children('small'))
            text += ' ' + $(this).children('small').text();
          {% if address_type == 'Adresse' %}
            $('#id_adresse').val(text);
            $('#id_adresse_uuid').val($(this).data('uuid'));
          {% elif address_type == 'Straße' %}
            $('#id_strasse').val(text);
            $('#id_strasse_uuid').val($(this).data('uuid'));
          {% endif %}
        {% else %}
          $('#id_address_search').val($(this).children('strong').text());
        {% endif %}
        FEATURE_GEOMETRY = json.features[$(this).data('feature')].geometry;
        if (FEATURE_GEOMETRY.type === 'Point') {
          window.currMap.fitBounds([
            [
              FEATURE_GEOMETRY.coordinates[1],
              FEATURE_GEOMETRY.coordinates[0]
            ],
            [
              FEATURE_GEOMETRY.coordinates[1],
              FEATURE_GEOMETRY.coordinates[0]
            ]
          ]);
        } else {
          window.currMap.fitBounds([
            [
              FEATURE_GEOMETRY.coordinates[0][0][1],
              FEATURE_GEOMETRY.coordinates[0][1][0]
            ],
            [
              FEATURE_GEOMETRY.coordinates[0][2][1],
              FEATURE_GEOMETRY.coordinates[0][0][0]
            ]
          ]);
        }
      });
    }


    function setAddressUuid() {
      /**
       * Adresse bzw. Straße auf Werte der entsprechenden Hidden-Input-Felder setzen
       */
      {% if address_type == 'Adresse' %}
        if ($.trim($('#id_adresse').val()).length)
          $('#id_adresse').val($('#id_adresse_uuid').val());
      {% elif address_type == 'Straße' %}
        if ($.trim($('#id_strasse').val()).length)
          $('#id_strasse').val($('#id_strasse_uuid').val());
      {% endif %}
      setCoordinates();

    }






    /**
     * @function
     * @name setCoordinates
     *
     * Koordinaten der gezeichneten Layer auf der Karten in Hidden-Inputfeld #id_geometry schreiben
     */
    function setCoordinates() {
      let jsonGeometrie;
      if (currMap.pm.getGeomanDrawLayers().length < 1){
        jsonGeometrie = {
          'type': '{{ geometry_type }}',
          {% if geometry_type == "Point" %}
            'coordinates': [0, 0],
          {% elif geometry_type == "Polygon" %}
            'coordinates': [[]],
          {% else %}
            'coordinates': [],
          {% endif %}
          };
        $('#id_geometrie').val(JSON.stringify(jsonGeometrie));
      } else {
        {% if geometry_type == 'MultiPolygon' or geometry_type == 'MultiPoint' or geometry_type == 'MultiLineString' %}
          let coords = [];
          let temp;

          currMap.pm.getGeomanDrawLayers().forEach(function (layer) {
            temp = layer.toGeoJSON().geometry;
            // Geoman malt mit Polygonen. Daher überprüfen ob Layer Polygon oder Multipolygon ist.
            if (temp.type.search('Multi') > -1) {
              for (let i = 0; i < temp.coordinates.length; i++) {
                coords.push(temp.coordinates[i]);
              }
            } else {
              coords.push(temp.coordinates);
            }
          });
          jsonGeometrie = {
            'type': '{{ geometry_type }}',
            'coordinates': coords,
          };
        {% else %}
          jsonGeometrie = currMap.pm.getGeomanDrawLayers()[0].toGeoJSON().geometry;
        {% endif %}
        $('#id_geometrie').val(JSON.stringify(jsonGeometrie));
      }
    }

    {% if gpx_input %}
      $('#id_gpx').change(function(e) {
        /**
         * @function
         * Bei Auswahl von Datei im GPX-Upload Feld, wird Label mit Dateinamen überschrieben und die ausgewählte GPX zum
         * Server geschickt. Als Response wird der Inhalt der GPX als GeoJson erwartet mit den zusätzlichen Attributen
         * 'Startzeitpunkt' und Endzeitpunkt. Diese Attribute werden beim Empfangen in die dafür vorgesehenen Input-Felder
         * geschrieben und die Geometrie auf der Karte gezeichnet.
         *
         * @param e
         */

        var modal = new bootstrap.Modal($('#id_gpxLoading'));
        modal.show();

        let file = e.target.files[0];
        let fileName = file.name;
        let formData = new FormData();
        formData.append('gpx', file);

        // Geoman-Layer von Karte entfernen (falls vorher schon eine Datei hochgeladen wurde)
        currMap.pm.getGeomanLayers().forEach((layer) => {
          if (layer.toGeoJSON().properties.datenthema !== 'Fallwildsuchen_Kontrollgebiete'){
            layer.remove();
          }
        });

        // Upload der GPX-Datei und Warten auf Response
        fetch(
          '{% url "datenmanagement:gpxtogeojson" %}', {
            method: 'POST',
            body: formData,
          }
        ).then(
          (response) => {
            return response.json();
          }
        ).then(
          (data) => {
            // Wenn data StatusCode enthält (Fehler bei der Kommunikation mit FME) => Ausgabe des Fehlers
            if (data.StatusCode){
              console.log('Fehler bei Kommunikation mit FME');
              console.log(data);
            } else {
              // Start- und Endzeitpunkte aus Json auslesen
              let start = new Date(data.features[0].properties.startzeitpunkt);
              let ende = new Date(data.features[0].properties.endzeitpunkt);
              // Startzeitpunkt umwandeln in benötigtes Format (DD.MM.YYYY HH:mm:ss)
              let stringStartDate = new Intl.DateTimeFormat(
                'de-DE', {
                  month: '2-digit', day: '2-digit', year: 'numeric',
                }).format(start);
              let stringStartTime = new Intl.DateTimeFormat(
                'de-DE', {
                  hour: 'numeric', minute: 'numeric', second: 'numeric',
                  hour12: false
                }).format(start);
              // Endzeitpunkt umwandeln in benötigtes Format (DD.MM.YYYY HH:mm:ss)
              let stringEndeDate = new Intl.DateTimeFormat(
                'de-DE', {
                  month: '2-digit', day: '2-digit', year: 'numeric'
                }).format(ende);
              let stringEndeTime = new Intl.DateTimeFormat(
                'de-DE', {
                  hour: 'numeric', minute: 'numeric', second: 'numeric',
                  hour12: false
                }).format(ende);
              // Start- und Endzeitpunkt in Inputfelder schreiben
              $('#id_startzeitpunkt').val(String(stringStartDate + ' ' + stringStartTime));
              $('#id_endzeitpunkt').val(String(stringEndeDate + ' ' + stringEndeTime));
              // Layer erzeugen
              let track = new L.geoJSON(data, {
                color: 'red',
              });
              // Layer und alle Sublayer zu Geoman Draw Layer hinzufügen
              track._changeGeom = true;
              track.eachLayer((layer) => {
                layer._drawnByGeoman = true;
              });
              // Layer zur Karte hinzufügen
              track.addTo(currMap);
            }
            modal.hide();
          }
        ).catch(
          (error) => {
            $('#id_gpxLoading-header').append(
              '<button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>'
            );
            $('#id_gpxLoading-title').text('Fehler bei Kommunikation mit Server');
            $('#id_gpxLoading-body').text(
              'Es ist ein Fehler bei der Kommunikation mit dem Server aufgetreten. ' +
              'Bitte versuchen Sie es erneut oder kontaktieren Sie einen Administrator.'
            );
            $('#id_gpxLoading-body').after(
              '<div class="modal-footer">' +
                '<button type="button" class="btn btn-primary" data-bs-dismiss="modal">schließen</button>' +
              '</div>'
            );
            console.log(error);
          }
        );
      });
    {% endif %}


    {% if model_name == "Fallwildsuchen_Nachweise" %}
      /**
       * @function
       *
       * Laden des ausgewählten Kontrollgebietes im Rahmen einer Fallwildsuche
       */
      $('#id_kontrollgebiet').change(function() {
        let element = $('#id_kontrollgebiet option:selected')[0];
        let url = "{% url 'datenmanagement:'|add:'Fallwildsuchen_Kontrollgebiete'|add:'geometry' %}";
        currMap.pm.getGeomanLayers().forEach((layer) => {
          if (layer.toGeoJSON().properties.datenthema){
            layer.remove();
          }
        });
        fetch(
          String(url + '?pk=' + element.getAttribute('value'))
        ).then(
          (response) => {
            return response.json();
          }
        ).then(
          (data) => {
            let wkt = new Wkt.Wkt();
            let geom = data.geometry;
            wkt.read(geom.substring(geom.indexOf(';') + 1, geom.length));
            let geoJsonFeature = {
              type: 'Feature',
              geometry: null,
              properties: {
                'uuid': data.uuid,
                'datenthema': data.model_name,
              },
              crs: {
                type: 'name',
                properties: {
                  'name': 'urn:ogc:def:crs:EPSG::4326'
                }
              }
            };
            geoJsonFeature.geometry = wkt.toJson();
            new L.geoJSON(geoJsonFeature).addTo(currMap);
          }
        ).catch(
          (error) => {
            console.log(error);
          }
        );
      });
    {% endif %}



    /*
      Lizenz und Copyright Hinweise für leaflet-geoman:

      MIT License

      Copyright (c) 2017 Sumit Kumar

      Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:

      The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
     */


  </script>
{% endblock %}
