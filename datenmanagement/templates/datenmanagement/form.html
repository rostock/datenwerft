{% extends "navbar.html" %}
{% load datenmanagement_tags %}
{% load leaflet_tags %}
{% load static %}

{% block title %}{{ model_verbose_name_plural }} – Formular | {% endblock %}

{% block style %}
  {{ block.super }}
  {% leaflet_css plugins="geoman,locatecontrol" %}
  <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/form.css' %}">
  {% if forms_in_mobile_mode or request.user_agent.is_mobile or request.user_agent.is_tablet %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/form-mobile.css' %}">
    {% if forms_in_mobile_mode %}
      <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/form-mobile-mode.css' %}">
    {% endif %}
  {% else %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/form-desktop.css' %}">
  {% endif %}
{% endblock %}

{% block scripts %}
  {{ block.super }}
  {% leaflet_js plugins="geoman,locatecontrol" %}
  <script src="{% static 'proj4/proj4.js' %}"></script>
  <script src="{% static 'wicket/wicket.js' %}"></script>
  <script src="{% static 'wicket/wicket-leaflet.js' %}"></script>
  <script src="{% static 'proj4leaflet/proj4leaflet.js' %}"></script>
  <script type="module" src="{% static 'martinez-polygon-clipping/martinez.min.js' %}"></script>
  <script src="{% static 'datenmanagement/js/cartographicHelpers.js' %}"></script>
  <script src="{% static 'datenmanagement/js/genericHelpers.js' %}"></script>
  <script type="module" src="{% static 'datenmanagement/js/leafletHelpers.js' %}"></script>
{% endblock %}

{% block content %}
  {% if form.errors %}
    {% for field in form %}
      {% for error in field.errors %}
        <div class="alert alert-danger" role="alert">
          <i class="fa-solid fa-circle-exclamation"></i>
          {% autoescape off %}
            {{ error }}
          {% endautoescape %}
        </div>
      {% endfor %}
    {% endfor %}
    {% for error in form.non_field_errors %}
      <div class="alert alert-danger" role="alert">
        <i class="fa-solid fa-circle-exclamation"></i>
        {{ error|customize_error_message }}
      </div>
    {% endfor %}
    <div class="mb-4"></div>
  {% endif %}
  {% if associated_new %}
    <div class="alert alert-primary" role="alert">
      <h5 class="alert-heading">assoziierte Datensätze</h5>
      {% if object and associated_objects %}
        <ul>
          {% for associated_object in associated_objects %}
            <li>{{ associated_object.title }} {{ associated_object.name }} <a href="{{ associated_object.link }}" target="_blank" rel="noopener noreferrer" title="{{ associated_object.title }} ansehen oder bearbeiten"><i class="fas fa-arrow-up-right-from-square"></i></a></li>
            {% if associated_object.preview_img_url %}
              <a href="{{ associated_object.preview_img_url }}" target="_blank" rel="noopener noreferrer" title="große Ansicht öffnen…">
                <img src="{% if associated_object.preview_thumb_url %}{{ associated_object.preview_thumb_url }}{% else %}{{ associated_object.preview_img_url }}{% endif %}" alt="Vorschau" width="50px">
              </a>
            {% endif %}
          {% endfor %}
        </ul>
      {% else %}
        (noch) keine assoziierten Datensätze vorhanden
      {% endif %}
      {% if user|user_has_model_change_permission:model_name_lower %}
        <hr>
        {% for associated_new_entry in associated_new %}
          <p class="{% if forloop.last %}mb-1{% else %}mb-3{% endif %}">
            <a class="btn btn-primary" role="button" href="{{ associated_new_entry.link }}" target="_blank" rel="noopener noreferrer"><i class="fas fa-arrow-up-right-from-square"></i> {{ associated_new_entry.title }} anlegen</a>
          </p>
        {% endfor %}
      {% endif %}
    </div>
    <div class="mb-4"></div>
  {% endif %}
  <form class="form" method="post" enctype="multipart/form-data" action="">
    {% csrf_token %}
    <div {% if geometry_type %}id="custom-form"{% endif %}>
      <table class="table">
        {% for field in form %}
          {% if not field|is_field_address_related_field and not field|is_field_geometry_field %}
            <tr>
              <td>
                {% if field.name in catalog_link_fields_names %}
                  {{ field.label_tag }}
                  <small>(<a href="{{ catalog_link_fields|get_dict_value_by_key:field.name }}"><i class="fas fa-circle-info"></i> ALKIS-Katalog</a>)</small>
                {% elif field|is_field_hours_related_field %}
                  {{ field.label_tag }} <small>(<a href="{% static 'hilfe/work/datensatz-anlegen.html' %}#datensatz-anlegen-oeffnungszeiten"><i class="fas fa-circle-question"></i> Hilfe</a>)</small>
                {% elif fields_with_foreign_key_to_linkify and field.name in fields_with_foreign_key_to_linkify %}
                  {% if object and user|user_has_model_change_permission:model_name_lower and object|get_value_of_field:field.name %}
                    {% with foreign_model=object|get_value_of_field:field.name|get_class_name %}
                      {{ field.label_tag }}
                      <a href="{% url 'datenmanagement:'|add:foreign_model|add:'_change' field.value %}" id="link_{{ field.name }}"> <i class="fas fa-arrow-up-right-from-square" title="{{ field.label }} ansehen oder bearbeiten"></i></a>
                    {% endwith %}
                  {% else %}
                    {% with foreign_model=field.name|get_foreign_key_field_class_name:model_name %}
                      {{ field.label_tag }}<a hidden href="{% url 'datenmanagement:'|add:foreign_model|add:'_change' foreign_model %}" id="link_{{ field.name }}"> <i class="fas fa-arrow-up-right-from-square" title="{{ field.label }} ansehen oder bearbeiten"></i></a>
                    {% endwith %}
                  {% endif %}
                  {% with foreign_model=field.name|get_foreign_key_field_class_name:model_name %}
                    {% if geometry_type and foreign_model|has_model_geometry_field %}
                      <span> <i id="{{ field.name }}-value-assigner" data-foreign-model="{{ foreign_model }}" data-field-title="{{ field.label }}" data-field-name="{{ field.name }}" class="fa-solid fa-map-location-dot text-primary enabled value-assigner" title="{{ field.label }} via Karte auswählen"></i></span>
                    {% endif %}
                  {% endwith %}
                {% elif postcode_assigner and field.name == postcode_assigner %}
                  {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_model_change_permission:model_name_lower %}
                    {{ field.label_tag }} <span><i id="postcode-assigner" class="fas fa-gears text-{% if geometry %}primary enabled{% else %}secondary{% endif %}"{% if geometry %} title="Postleitzahl automatisch zuweisen"{% endif %}></i></span>
                  {% endif %}
                {% else %}
                  {{ field.label_tag }}
                {% endif %}
              </td>
              {% autoescape off %}
                <td>
                  {{ field }}
                </td>
              {% endautoescape %}
            </tr>
          {% endif %}
        {% endfor %}
        {% if gpx_input %}
          <tr>
            <td>
              <label for="id_gpx" class="required">GPX-Datei</label>
            </td>
            <td>
              <div class="custom-file">
                <input class="form-control" type="file" id="id_gpx" name="gpx" accept=".gpx">
              </div>
            </td>
          </tr>
        {% endif %}
      </table>
    </div>
    {% if geometry_type %}
      <div id="map-adresssearch-container-form">
        <label hidden for="id_geometrie" class="form-label">Geometrie</label>
        {% if geometry %}
          <textarea hidden id="id_geometrie" class="required django-leaflet-raw-textarea" name="geometrie" cols="150" rows="4">{{ geometry }}</textarea>
        {% else %}
          <textarea hidden id="id_geometrie" class="required django-leaflet-raw-textarea" name="geometrie" cols="150" rows="4">{ "type": "{{ geometry_type }}", "coordinates": [] }</textarea>
        {% endif %}
        {% leaflet_map "id-geometrie-map" callback="window.mapCallbackFunction" %}
        {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_model_change_permission:model_name_lower %}
          {% if geometry_type == 'Point' or address_type and not address_mandatory %}
            <div class="d-grid mt-3 gap-2 d-md-block">
              {% if geometry_type == 'Point' %}
                <button disabled id="addressToMap" class="btn btn-primary" type="button"><i class="fas fa-location-dot"></i> Marker setzen</button>
              {% endif %}
              {% if not address_mandatory %}
                {% if address_type == 'Adresse' %}
                  <button disabled id="mapToAddress" class="btn btn-primary" type="button"><i class="fas fa-house"></i> Adresse übernehmen</button>
                {% elif address_type == 'Straße' %}
                  <button disabled id="mapToStreet" class="btn btn-primary" type="button"><i class="fas fa-road"></i> Straße übernehmen</button>
                {% elif address_type == 'Gemeindeteil' %}
                  <button disabled id="mapToQuarter" class="btn btn-primary" type="button"><i class="fas fa-circle-dot"></i> Gemeindeteil übernehmen</button>
                {% endif %}
              {% endif %}
            </div>
          {% endif %}
        {% endif %}
        <div class="mt-3">
          {% if address_type %}
            {% if address_type == 'Adresse' %}
              <label for="id_adresse" class="form-label{% if address_mandatory %} required{% endif %}">{{ address_type }}</label>
              <div class="form-floating">
                {{ form.adresse }}
                <label for="id_adresse">{{ address_type }} eingeben…</label>
              </div>
              <input id="id_adresse_uuid" type="hidden" name="adresse_uuid" value="{% if current_address %}{{ current_address }}{% endif %}">
            {% elif address_type == 'Straße' %}
              <label for="id_strasse" class="form-label{% if address_mandatory %} required{% endif %}">{{ address_type }}</label>
              <div class="form-floating">
                {{ form.strasse }}
                <label for="id_strasse">{{ address_type }} eingeben…</label>
              </div>
              <input id="id_strasse_uuid" type="hidden" name="strasse_uuid" value="{% if current_street %}{{ current_street }}{% endif %}">
            {% elif address_type == 'Gemeindeteil' %}
              <label for="id_gemeindeteil" class="form-label{% if address_mandatory %} required{% endif %}">{{ address_type }}</label>
              <div class="form-floating">
                {{ form.gemeindeteil }}
                <label for="id_gemeindeteil">{{ address_type }} eingeben…</label>
              </div>
              <input id="id_gemeindeteil_uuid" type="hidden" name="gemeindeteil_uuid" value="{% if current_quarter %}{{ current_quarter }}{% endif %}">
            {% endif %}
          {% else %}
            {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_model_change_permission:model_name_lower %}
              <label for="address-search" class="form-label">Adressensuche</label>
              <div class="form-floating">
                <input id="address-search" type="text" class="form-control" name="address_search" autocapitalize="off" autocomplete="off" placeholder="Adresse, Straße oder Gemeindeteil eingeben…">
                <label for="address-search">Adresse, Straße oder Gemeindeteil eingeben…</label>
              </div>
            {% endif %}
          {% endif %}
          <div id="results-container" class="results"></div>
        </div>
      </div>
    {% endif %}
    <div id="buttons">
      <div class="d-grid mt-5 mb-3 gap-2 d-md-block">
        {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_model_change_permission:model_name_lower %}
          <button class="btn btn-primary" type="submit" onclick="setFinalGeometry();"><i class="fas fa-floppy-disk"></i> {% if not forms_in_mobile_mode and not request.user_agent.is_mobile and not request.user_agent.is_tablet %}{% if object %}Änderungen{% else %}neuen Datensatz{% endif %} {% endif %}speichern</button>
        {% endif %}
        {% if object and user|user_has_model_add_permission:model_name_lower %}
          <button class="btn btn-primary" type="submit" onclick="setFinalGeometry(); cloneObject();"><i class="fas fa-clone"></i> {% if not forms_in_mobile_mode and not request.user_agent.is_mobile and not request.user_agent.is_tablet %}als neuen Datensatz {% endif %}klonen</button>
        {% endif %}
        {% if object and user|user_has_model_delete_permission:model_name_lower %}
          <a class="btn btn-danger" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'_delete' object.pk %}"><i class="fas fa-trash"></i> {% if not forms_in_mobile_mode and not request.user_agent.is_mobile and not request.user_agent.is_tablet %}Datensatz {% endif %}löschen</a>
        {% endif %}
        <a class="btn btn-warning" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'_start' %}"><i class="fas fa-hand"></i> abbrechen</a>
      </div>
    </div>
    {% include "modal-error.html" %}
    {% if gpx_input %}
      {% include "modal-loading.html" %}
    {% endif %}
  </form>
  <script>
    /**
     * @function
     * @name mapCallbackFunction
     *
     * behandelt als Callback-Funktion die übergebene Karte
     *
     * @param {Object} map - Karte
     */
    function mapCallbackFunction(map) {
      // Konstanten für Karte setzen
      setMapConstants(map);

      // ggf. zusätzliche WMS-Layer definieren,
      // die dann beim Konfigurieren der Karte zu den Overlay-Karten hinzugefügt werden
      let additionalWMSLayers = {}, additionalWMSLayerUrl;
      {% for additional_wms_layer in additional_wms_layers %}
        additionalWMSLayerUrl = '{{ additional_wms_layer.url }}';
        if ('{{ additional_wms_layer.proxy }}'.toLowerCase() === 'true')
          additionalWMSLayerUrl = '{% url "toolbox:owsproxy" %}' + additionalWMSLayerUrl;
        additionalWMSLayers['{{ additional_wms_layer.title }}'] = L.tileLayer.wms(
          additionalWMSLayerUrl, {
            layers: '{{ additional_wms_layer.layers }}',
            format: map._wmsFormat,
            maxZoom: map._maxLayerZoom,
            transparent: true
          }
        );
      {% empty %}
      {% endfor %}

      // Karte konfigurieren
      configureMap(map, '{% url "toolbox:owsproxy" %}', additionalWMSLayers);

      // Karte auch in anderen Scopes
      // bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
      window.currMap = map;

      // bei mobilen Geräten: Standortbestimmung hinzufügen
      {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
        enableMapLocate(map);
      {% endif %}

      // globale Marker für Leaflet konfigurieren und auch in anderen Scopes
      // bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
      window.redMarker = new L.Icon({
        shadowUrl: '{% static "datenmanagement/img/leaflet-markers/marker-shadow.png" %}',
        iconUrl: '{% static "datenmanagement/img/leaflet-markers/marker-red.svg" %}',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });
      window.orangeMarker = new L.Icon({
        shadowUrl: '{% static "datenmanagement/img/leaflet-markers/marker-shadow.png" %}',
        iconUrl: '{% static "datenmanagement/img/leaflet-markers/marker-orange.svg" %}',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });
      window.grayMarker = new L.Icon({
        shadowUrl: '{% static "datenmanagement/img/leaflet-markers/marker-shadow.png" %}',
        iconUrl: '{% static "datenmanagement/img/leaflet-markers/marker-gray.svg" %}',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });

      // globale Variable für Feature-Geometrie auch in anderen Scopes
      // bzw. außerhalb der Funktion mapCallbackFunction verfügbar machen
      window.featureGeometry = [];

      // Leaflet-Geoman konfigurieren
      {% if not gpx_input %}
        {% if 'LineString' in geometry_type %}
          configureLeafletGeoman(map, 'LineString');
        {% elif geometry_type == 'Point' or geometry_type == 'Polygon' or geometry_type == 'MultiPolygon' %}
          configureLeafletGeoman(map, '{{ geometry_type }}');
        {% else %}
          configureLeafletGeoman(map);
        {% endif %}
      {% else %}
        configureLeafletGeoman(map);
      {% endif %}

      // falls Geometrie vorhanden...
      {% if geometry %}
        // vorhandene Geometrie auf Karte anzeigen
        map.loadGeometryFromField('#id_geometrie')
        // ggf. Geometrien der Zielobjekte von Fremdschlüsseln auf Karte anzeigen
        {% if fields_with_foreign_key_to_linkify %}
          {% for field in fields_with_foreign_key_to_linkify %}
            {% if object|get_value_of_field:field %}
              {% with foreign_model=field|get_foreign_key_field_class_name:model_name %}
                {% if foreign_model|has_model_geometry_field %}
                  let url = "{% url 'datenmanagement:'|add:foreign_model|add:'_geometry' %}" + '?pk=' + '{{ object|get_foreign_key_object_pk:field }}';
                  {% with field_title=field|get_field_verbose_name:model_name %}
                    map.loadGeometryFromForeignKeyFieldObjects(
                      url,
                      '{{ foreign_model }}',
                      '{{ field }}',
                      '{{ field_title }}',
                      '{{ object|get_value_of_field:field }}'
                    );
                  {% endwith %}
                {% endif %}
              {% endwith %}
            {% endif %}
          {% endfor %}
        {% endif %}
      {% endif %}

      // ggf. zusätzliche Datenthemen definieren,
      // die dann zum Zuschalten in der Karte angeboten werden
      {% if model_list and not gpx_input %}
        // Layer-Control hinzufügen zum Zuschalten zusätzlicher Datenthemen
        let dataThemeControl = new L.control.layers({}, {}).addTo(map);
        // alle zusätzlichen Datenthemen durchgehen...
        {% for key, value in model_list.items %}
          {% with datenthema_name_lower=key|lower %}
            map._themaUrl = {
              ...map._themaUrl,
              '{{ value }}': '{% url 'datenmanagement:'|add:key|add:'_geometry' %}'
            };
            // neuen GeoJSON-Layer für Datenthema initialisieren und mit Namen versehen
            let {{ datenthema_name_lower }} = new L.Proj.geoJson();
            {{ datenthema_name_lower }}.name = '{{ value }}';
            // GeoJSON-Layer für Datenthema zur Layer-Control hinzufügen
            dataThemeControl.addOverlay({{ datenthema_name_lower }}, '{{ value }}')
            // beim Zuschalten des GeoJSON-Layers Datenthema-Features laden
            {{ datenthema_name_lower }}.on('add', function () {
              if (map.getZoom() > map._minLayerZoomForDataThemes) {
                // Datenthema-Features zum entsprechenden GeoJSON-Layer hinzufügen
                map.loadExternalData(
                  '{{ value }}',
                  '{% url 'datenmanagement:'|add:key|add:'_geometry' %}',
                  this
                );
                map.eachLayer((layer) => {
                  // GeoJSON-Layer „anheben“, der bearbeitet wird
                  if (layer._drawnByGeoman === true) {
                    if (layer instanceof L.Marker)
                      layer.setZIndexOffset(1000);
                    else
                      layer.bringToFront();
                  }
                });
              } else if (window.showDataThemesZoomModal === true) {
                let zoomDifference = map._minLayerZoomForDataThemes - map.getZoom() + 1;
                zoomDifference += zoomDifference === 1 ? ' Stufe' : ' Stufen';
                toggleModal(
                  $('#error-modal'),
                  'Sichtbarkeit zusätzlicher Datenthemen',
                  'Sie müssen zunächst ' + zoomDifference + ' in die Karte hineinzoomen, bevor die zusätzlichen Datenthemen sichtbar werden!'
                );
                window.showDataThemesZoomModal = false;
              }
            });
          {% endwith %}
        {% endfor %}

        // beim Bewegen der Karte Datenthema-Features nachladen
        map.on('moveend', () => {
          map.updateMap(dataThemeControl);
        });
      {% endif %}

      // ggf. zusätzliche WFS-Feature-Types definieren,
      // die dann zum Zuschalten in der Karte angeboten werden
      {% if additional_wfs_featuretypes %}
        // Layer-Control hinzufügen zum Zuschalten zusätzlicher WFS-Feature-Types
        let featureTypeControl = new L.control.layers({}, {}).addTo(map);
        // alle zusätzlichen WFS-Feature-Types durchgehen...
        {% for additional_wfs_featuretype in additional_wfs_featuretypes %}
          if ('{{ additional_wfs_featuretype.proxy }}'.toLowerCase() === 'true') {
            map._themaUrl = {
              ...map._themaUrl,
              '{{ additional_wfs_featuretype.title }}': '{% url "toolbox:owsproxy" %}' + '{{ additional_wfs_featuretype.url }}' + map._wfsDefaultParameters.replace('TYPENAMES', '{{ additional_wfs_featuretype.featuretypes }}')
            };
          } else {
            map._themaUrl = {
              ...map._themaUrl,
              '{{ additional_wfs_featuretype.title }}': '{{ additional_wfs_featuretype.url }}' + map._wfsDefaultParameters.replace('TYPENAMES', '{{ additional_wfs_featuretype.featuretypes }}')
            };
          }
          // neuen GeoJSON-Layer für WFS-Feature-Type initialisieren und mit Namen versehen
          let {{ additional_wfs_featuretype.name }} = new L.Proj.geoJson();
          {{ additional_wfs_featuretype.name }}.name = '{{ additional_wfs_featuretype.title }}';
          // GeoJSON-Layer für WFS-Feature-Type zur Layer-Control hinzufügen
          featureTypeControl.addOverlay({{ additional_wfs_featuretype.name }}, '{{ additional_wfs_featuretype.title }}')
          // beim Zuschalten des GeoJSON-Layers WFS-Features laden
          {{ additional_wfs_featuretype.name }}.on('add', function () {
            if (map.getZoom() > map._minLayerZoomForWFSFeaturetypes) {
              // WFS-Features zum entsprechenden GeoJSON-Layer hinzufügen
              let url = '{{ additional_wfs_featuretype.url }}' + map._wfsDefaultParameters.replace('TYPENAMES', '{{ additional_wfs_featuretype.featuretypes }}');
              if ('{{ additional_wfs_featuretype.proxy }}'.toLowerCase() === 'true')
                url = '{% url "toolbox:owsproxy" %}' + url;
              map.loadExternalData(
                '{{ additional_wfs_featuretype.title }}',
                url,
                this,
                true
              );
              map.eachLayer((layer) => {
                // GeoJSON-Layer „anheben“, der bearbeitet wird
                if (layer._drawnByGeoman === true) {
                  if (layer instanceof L.Marker)
                    layer.setZIndexOffset(1000);
                  else
                    layer.bringToFront();
                }
              });
            } else if (window.showWFSZoomModal === true) {
              let zoomDifference = map._minLayerZoomForWFSFeaturetypes - map.getZoom() + 1;
              zoomDifference += zoomDifference === 1 ? ' Stufe' : ' Stufen';
              toggleModal(
                $('#error-modal'),
                'Sichtbarkeit zusätzlicher WFS-Feature-Types',
                'Sie müssen zunächst ' + zoomDifference + ' in die Karte hineinzoomen, bevor die zusätzlichen WFS-Feature-Types sichtbar werden!'
              );
              window.showWFSZoomModal = false;
            }
          });
        {% endfor %}

        // beim Bewegen der Karte WFS-Features nachladen
        map.on('moveend', () => {
          map.updateMap(featureTypeControl, true);
        });
      {% endif %}

      /**
       * @function
       *
       * prüft beim Start des Modus „Zeichnen“, ob es bereits einen Leaflet-Geoman-Layer gibt, und löscht diesen gegebenenfalls
       */
      map.on('pm:drawstart', function () {
        {% if geometry_type == 'Point' or geometry_type == 'LineString' or geometry_type == 'Polygon' %}
          if (map.pm.getGeomanLayers().length > 0) {
            map.pm.getGeomanLayers().forEach((item) => {
              if (item._drawnByGeoman === true)
                map.removeLayer(item);
            })
          }
        {% endif %}
      });

      // falls Datenmodell Adressenbezug vorsieht...
      {% if address_type %}
        /**
         * @function
         *
         * setzt, falls der Adressenbezug verpflichtend ist,
         * beim Hinzufügen oder Editieren einer Geometrie die Adresse oder die Straße
         * und schaltet bei Bedarf die Postleitzahl-Auto-Zuweisung frei
         *
         * @param {Object} layer - Layer (= Feature)
         */
        map.on('pm:create', function ({layer}) {
          {% if address_mandatory %}
            // Adressenbezug für gesetze Geometrie setzen
            setAddressReference('{{ address_type }}', layer);
            // bei Bewegungs-Event Adressenbezug neu setzen
            {% if geometry_type == 'Point' %}
              layer.on('pm:dragend', (e) => {
                setAddressReference('{{ address_type }}', e.layer);
              });
            {% else %}
              layer.on('pm:update', (e) => {
                setAddressReference('{{ address_type }}', e.layer);
              });
            {% endif %}
            // bei Bedarf Postleitzahl-Auto-Zuweisung freischalten
            {% if postcode_assigner %}
              enablePostcodeAssigner();
            {% endif %}
          {% else %}
            // passenden Button zur Übernahme des aktuellen Adressenbezugs der Geometrie in der Karte freischalten
            enableAddressReferenceButton();
          {% endif %}
        });
      {% endif %}
    }

    /**
     * @function
     *
     * Hauptfunktion
     */
    $(document).ready(function () {
      // globale Variablen für die Anzeige des Hinweis-Modals
      // in Bezug auf das Zuschalten zusätzlicher Datenthemen und/oder WFS-Feature-Types
      window.showWFSZoomModal = true;
      window.showDataThemesZoomModal = true;

      // falls Gruppe von Benutzern gesetzt ist, die für das Feld Ansprechpartner:in/Bearbeiter:in in einer entsprechenden Auswahlliste genutzt werden sollen...
      {% if group_with_users_for_choice_field %}
        // alle Felder durchgehen...
        {% for field in form %}
          // beim Feld Ansprechpartner:in/Bearbeiter:in...
          {% if field.name == 'ansprechpartner' or field.name == 'bearbeiter' %}
            let select = $('select#id_' + '{{ field.name }}');
            // Bootstratp-5-CSS-Klasse ergänzen
            select.addClass('form-select');
            // passenden Wert vorauswählen, wenn die darin enthaltende E-Mail-Adresse mit dem Feldwert übereinstimmt
            {% if object %}
              select.children().each(function () {
                let optionValue = $(this).val();
                if (optionValue.indexOf('{{ field.value }}'.toLowerCase()) !== -1)
                  select.val(optionValue);
              });
            {% endif %}
          {% endif %}
        {% endfor %}
      {% endif %}

      // Checkboxen in Multiple-Choice-Feldern an Bootstrap 5 anpassen
      $('ul input[type="checkbox"]').each(function () {
        $(this).addClass('form-check-input');
      });

      // Checkboxen in Multiple-Choice-Feldern an Bootstrap 5 anpassen
      $('ul input[type="checkbox"]').each(function () {
        $(this).addClass('form-check-input');
      });

      // Read-only-Felder behandeln
      {% if readonly_fields %}
        let inputField;
        {% for field in readonly_fields %}
          inputField = $('input#id_' + '{{ field }}');
          {% if object and user|user_has_model_change_permission:model_name_lower %}
            if (!inputField.val()) {
              inputField.closest('tr').hide();
            } else {
              let wert = inputField.val();
              if (inputField.attr('type') === 'date') {
                let datum = new Date(inputField.val());
                wert = datum.toLocaleDateString('de-DE', options = {
                  day: '2-digit',
                  month: '2-digit',
                  year: 'numeric'
                });
              }
              inputField.parent().append('<span id="' + inputField.attr('id') + '" title="nicht editierbar – automatisch vergeben"><em>' + wert + '</em></span>');
              let label = inputField.parent().closest('tr').find('label');
              label.wrapInner('<em></em>');
              inputField.hide();
            }
          {% else %}
            inputField.closest('tr').hide();
          {% endif %}
        {% endfor %}
      {% endif %}

      // falls Benutzer kein Änderungsrecht am Datenmodell hat...
      {% if not user|user_has_model_change_permission:model_name_lower %}
        // alle Felder deaktivieren
        $('input').each(function () {
          $(this).prop('disabled', true);
        });
        $('select').each(function () {
          $(this).prop('disabled', true);
        });
        $('textarea').each(function () {
          $(this).prop('disabled', true);
        });
      {% endif %}

      // Multi-Foto-Upload-Feld behandeln
      let fotoField = $('input#id_foto');
      if (fotoField.length) {
        fotoField.attr('accept', 'image/*');
        {% if multi_foto_field %}
          if (fotoField[0].files.length === 0)
            fotoField.attr('multiple', 'multiple');
        {% endif %}
      }

      // PDF-Upload-Feld behandeln
      let pdfField = $('input#id_pdf');
      if (pdfField.length) {
        pdfField.attr('accept', 'application/pdf');
      }

      // Adressensuche initialisieren
      // dabei Resultate der Adressensuche auch in anderen Scopes bzw. außerhalb der Hauptfunktion verfügbar machen
      window.results = $('div.results');
      {% if address_type %}
        window.addressType = '{{ address_type }}';
      {% else %}
        window.addressType = '';
      {% endif %}
      if (window.addressType === 'Adresse') {
        window.searchField = $('#id_adresse');
        window.addressUuidField = $('#id_adresse_uuid');
      } else if (window.addressType === 'Straße') {
        window.searchField = $('#id_strasse');
        window.addressUuidField = $('#id_strasse_uuid');
      } else if (window.addressType === 'Gemeindeteil') {
        window.searchField = $('#id_gemeindeteil');
        window.addressUuidField = $('#id_gemeindeteil_uuid');
      } else {
        window.searchField = $('#address-search');
        window.addressUuidField = null;
      }
      initializeAddressSearch(searchField, '{% url "toolbox:addresssearch" %}', addressType, addressUuidField);

      // bei Klick auf Button „Marker setzen“...
      $('#addressToMap').on('click', function () {
        // Marker in die Karte setzen, und zwar zentriert auf Ergebnis der Adressensuche
        setMarkerToAddressSearchResult(window.currMap);
        // passenden Button zur Übernahme des aktuellen Adressenbezugs der Geometrie in der Karte freischalten
        enableAddressReferenceButton();
        // bei Bedarf Postleitzahl-Auto-Zuweisung freischalten
        {% if postcode_assigner %}
          enablePostcodeAssigner();
        {% endif %}
      });

      // bei Klick auf Button „Adresse übernehmen“...
      $('#mapToAddress').on('click', function () {
        // aktuelle Adresse der Geometrie in der Karte übernehmen
        setAddressReference(window.addressType, window.currMap.pm.getGeomanLayers()[0]);
        $('#addressToMap').prop('disabled', false);
      });

      // bei Klick auf Button „Straße übernehmen“...
      $('#mapToStreet').on('click', function () {
        // aktuelle Straße der Geometrie in der Karte übernehmen
        setAddressReference(window.addressType, window.currMap.pm.getGeomanLayers()[0]);
        $('#addressToMap').prop('disabled', false);
      });

      // bei Klick auf Button „Gemeindeteil übernehmen“...
      $('#mapToQuarter').on('click', function () {
        // aktuellen Gemeindeteil der Geometrie in der Karte übernehmen
        setAddressReference(window.addressType, window.currMap.pm.getGeomanLayers()[0]);
        $('#addressToMap').prop('disabled', false);
      });

      // verhindern, dass HTML5-/jQuery-Fehlermeldungen bei Pflichtfeldern die Django-Fehlermeldungen überdecken
      $('[required]').removeAttr('required');

      // bei Desktop und bei vorhandener Karte:
      // vertikale Position der Buttons dynamisch setzen anhand von Position und Größe des Formulars (plus „Puffer“ von 20 Pixeln)
      {% if not forms_in_mobile_mode and not request.user_agent.is_mobile and not request.user_agent.is_tablet and geometry_type %}
        let top = $('#custom-form').position().top + $('#custom-form').height() + 20;
        $('#buttons').offset({
          top: top
        });
      {% endif %}

      // Labels für verpflichtende Boolean-Felder anpassen
      $('input[type="checkbox"]:not([value])').parent().parent().find('label').addClass('required');

      // Fremdschlüssel behandeln je nach aktueller Auswahl in entsprechendem Auswahlfeld:
      // a) Link auf Zielobjekt dynamisch anpassen
      //    (bei leerer Auswahl: Link verstecken)
      // b) ggf. Geometrie des Zielobjekts dynamisch auf Karte anzeigen (mit Tooltip = Auswahltext)
      //    (bei leerer Auswahl bzw. wenn Zieldatenmodell keine Geometrie aufweist: keine Geometrie anzeigen)
      {% if fields_with_foreign_key_to_linkify %}
        {% for field in fields_with_foreign_key_to_linkify %}
          {% with foreign_model=field|get_foreign_key_field_class_name:model_name %}
            $('select#id_' + '{{ field }}').each(function () {
              $(this).on('change', function () {
                let link = $('a#link_' + '{{ field }}');
                let href = link.prop('href');
                let text = $(this).find(':selected').text();
                let value = $(this).find(':selected').val();
                if (value) {
                  href = href.replace(/\/change\/.*/, '/change/' + value);
                  link.prop('href', href);
                  link.prop('hidden', false);
                } else
                  link.prop('hidden', true);
                {% if geometry_type and foreign_model|has_model_geometry_field %}
                  currMap.pm.getGeomanLayers().forEach((layer) => {
                    if (layer.toGeoJSON().properties.foreignkey === '{{ foreign_model }}') {
                      layer.remove();
                    }
                  });
                  if (value) {
                    let url = "{% url 'datenmanagement:'|add:foreign_model|add:'_geometry' %}" + '?pk=' + value;
                    {% with field_title=field|get_field_verbose_name:model_name %}
                      currMap.loadGeometryFromForeignKeyFieldObjects(
                        url,
                        '{{ foreign_model }}',
                        '{{ field }}',
                        '{{ field_title }}',
                        text
                      );
                      enableValueAssigner($('#{{ field }}-value-assigner'), '{{ field_title }} via Karte auswählen');
                    {% endwith %}
                  }
                {% endif %}
              });
            });
          {% endwith %}
        {% endfor %}
      {% endif %}

      // Links auf vorhandene Fotos, PDF etc. immer in neuem Tab öffnen
      $('td').find('a').attr('title', 'in neuem Tab öffnen…');
      $('td').find('a').attr('target', '_blank');
      $('td').find('a').attr('rel', 'noopener noreferrer');

      // Links auf vorhandene Fotos, PDF etc. sowie entsprechende Upload-Buttons mit ordentlichem Text versehen
      $('td').find('a').parent().contents().filter(function () {
        return this.nodeType === 3
      }).remove();
      $('td').find('a').parent().find('input[type="file"]').before('ändern in: ');
      $('<br>').insertBefore($('input[type="checkbox"][name$="-clear"]'));
      $('label[for$="-clear_id"]').addClass('label-with-margin');
      $('label[for$="-clear_id"]').text('löschen');

      // bestimmte Werte in Auswahllisten mit Kleinbuchstaben versehen
      $('td').find('option').each(function () {
        if ($(this).text() === 'Unbekannt')
          $(this).text('unbekannt');
        else if ($(this).text() === 'Ja')
          $(this).text('ja');
        else if ($(this).text() === 'Nein')
          $(this).text('nein');
      });
    });

    /**
     * @function
     * @name disableValueAssigner
     *
     * @param {Object} valueAssigner - Auswählen-via-Karte-Icon
     *
     * deaktiviert Auswählen-via-Karte-Icon an einem Auswahlfeld zu einem Fremdschlüssel
     */
    function disableValueAssigner(valueAssigner) {
      valueAssigner.removeClass('text-primary enabled');
      valueAssigner.addClass('text-secondary');
      valueAssigner.attr('title', '');
    }

    /**
     * @function
     * @name enableValueAssigner
     *
     * @param {Object} valueAssigner - Auswählen-via-Karte-Icon
     * @param {String} tooltip - Tooltip
     *
     * aktiviert Auswählen-via-Karte-Icon an einem Auswahlfeld zu einem Fremdschlüssel
     */
    function enableValueAssigner(valueAssigner, tooltip) {
      valueAssigner.removeClass('text-secondary');
      valueAssigner.addClass('text-primary enabled');
      valueAssigner.attr('title', tooltip);
    }

    /**
     * @function
     * @name enablePostcodeAssigner
     *
     * aktiviert Postleitzahl-Auto-Zuweisung
     */
    function enablePostcodeAssigner() {
      $('#postcode-assigner').removeClass('text-secondary');
      $('#postcode-assigner').addClass('text-primary enabled');
      $('#postcode-assigner').attr('title', 'Postleitzahl automatisch zuweisen');
    }

    /**
     * @function
     * @name setMarkerToAddressSearchResult
     *
     * @param {Object} map - Karte
     *
     * setzt Marker in die Karte, und zwar zentriert auf Ergebnis der Adressensuche
     */
    function setMarkerToAddressSearchResult(map) {
      if (map.pm.getGeomanLayers().length > 0) {
        let layer = map.pm.getGeomanLayers()[0];
        if (layer._drawnByGeoman && layer._latlng) {
          let latLng = getFeatureGeometryLatLng(featureGeometry);
          if (latLng[0] !== 0 && latLng[1] !== 0)
            layer.setLatLng(latLng);
        }
      } else {
        {% if geometry_type == 'Point' %}
          let layer = new L.Marker(getFeatureGeometryLatLng(featureGeometry), {
            icon: redMarker
          });
          layer._drawnByGeoman = true;
          layer.addTo(window.currMap);
        {% endif %}
      }
    }

    /**
     * @function
     * @name enableAddressReferenceButton
     *
     * schaltet passenden Button zur Übernahme des aktuellen Adressenbezugs der Geometrie in der Karte frei
     */
    function enableAddressReferenceButton() {
      {% if address_type == 'Adresse' %}
        $('#mapToAddress').prop('disabled', false);
      {% elif address_type == 'Straße' %}
        $('#mapToStreet').prop('disabled', false);
      {% elif address_type == 'Gemeindeteil' %}
        $('#mapToQuarter').prop('disabled', false);
      {% endif %}
    }

    /**
     * @function
     * @name setAddressReference
     *
     * @param addressType - Typ des Adressenbezugs (Adresse, Straße oder Gemeindeteil)
     * @param {Object} layer - Layer
     *
     * übernimmt aktuellen Adressenbezug der Geometrie in der Karte
     */
    function setAddressReference(addressType, layer) {
      let geoJson = layer.toGeoJSON();
      let geometryType = '{{ geometry_type|lower }}';
      if (geometryType.indexOf('point') !== -1)
        geometryType = 'Point';
      else if (geometryType.indexOf('line') !== -1)
        geometryType = 'LineString';
      else
        geometryType = 'Polygon';
      let ort = getFeatureCenter(geoJson, geometryType);
      let url = '{% url "toolbox:reversesearch" %}';
      fetch(url + '?search_class=address&x=' + ort[0] + '&y=' + ort[1], {
        method: 'GET'
      })
      .then(response => response.json())
      .then(data => {
        if (ort[0] !== 0 && ort[1] !== 0)
          adoptReverseSearchResult(data, addressType);
      })
      .catch(error => console.log(error))
    }

    /**
     * @function
     * @name adoptReverseSearchResult
     *
     * @param {JSON} geoJson - Resultate der Suche nach Objekten in bestimmtem Radius um gegebene Koordinaten
     * @param {string} addressType - Typ des Adressenbezugs (Adresse, Straße oder Gemeindeteil)
     *
     * adaptiert die Resultate der Suche nach Objekten in bestimmtem Radius um gegebene Koordinaten
     */
    function adoptReverseSearchResult(geoJson, addressType) {
      let erfolg = false;
      jQuery.each(geoJson.features, function (index, item) {
        if (item.properties.objektgruppe === addressType) {
          let text = item.properties._title_.substring(item.properties._title_.lastIndexOf(', ') + 2);
          if (item.properties.gemeindeteil_abkuerzung)
            text += ' (' + item.properties.gemeindeteil_abkuerzung + ')';
          searchField.val(text);
          if (addressUuidField)
            addressUuidField.val(item.properties.uuid);
          erfolg = true;
          return false;
        }
      });
      if (erfolg === false)
        toggleModal(
          $('#error-modal'),
          'Keine automatische Zuordnung ' + (addressType === 'Gemeindeteil' ? 'eines ' : 'einer ') + addressType + (addressType === 'Gemeindeteil' ? 's' : '') + ' möglich!',
          'Bitte setzen Sie den Marker bzw. zeichnen Sie die Linie oder Fläche in der Karte {{ REVERSE_SEARCH_RADIUS }} m oder dichter an ' + (addressType === 'Gemeindeteil' ? 'den nächsten ' : 'die nächste ') + addressType +  ' heran.'
        );
    }

    /**
     * @function
     * @name setFinalGeometry
     *
     * übernimmt erstellte Geometrie(n) aus der Karte final in Feld #id_geometry
     */
    function setFinalGeometry() {
      {% if geometry_type %}
        let jsonGeometrie;
        if (currMap.pm.getGeomanDrawLayers().length < 1) {
          let coordinates;
          {% if geometry_type == 'Point' %}
            coordinates = [0, 0];
          {% elif geometry_type == 'Polygon' %}
            coordinates = [[]];
          {% else %}
            coordinates = [];
          {% endif %}
          jsonGeometrie = {
            'type': '{{ geometry_type }}',
            'coordinates': coordinates
          };
        } else {
          {% if geometry_type == 'MultiPolygon' or geometry_type == 'MultiPoint' or geometry_type == 'MultiLineString' %}
            let coordinates = [];
            let temp;
            currMap.pm.getGeomanDrawLayers().forEach(function (layer) {
              temp = layer.toGeoJSON().geometry;
              if (temp.type.search('Multi') > -1) {
                for (let i = 0; i < temp.coordinates.length; i++) {
                  coordinates.push(temp.coordinates[i]);
                }
              } else {
                coordinates.push(temp.coordinates);
              }
            });
            jsonGeometrie = {
              'type': '{{ geometry_type }}',
              'coordinates': coordinates,
            };
          {% else %}
            jsonGeometrie = currMap.pm.getGeomanDrawLayers()[0].toGeoJSON().geometry;
          {% endif %}
        }
        $('#id_geometrie').val(JSON.stringify(jsonGeometrie));
        // setzt Referenz aus Feld mit UUID der referenzierten Adresse,
        // der referenzierten Straße oder des referenzierten Gemeindeteils
        if (addressUuidField && $.trim(searchField.val()).length)
          searchField.val(addressUuidField.val());
      {% endif %}
    }

    /**
     * @function
     * @name cloneObject
     *
     * klont den gesamten Datensatz als neuen Datensatz
     */
    function cloneObject() {
      $('form').attr('action', "{% url 'datenmanagement:'|add:model_name|add:'_add' %}");
    }

    // beim Klick auf das Auswählen-via-Karte-Icon an einem Auswahlfeld zu einem Fremdschlüssel
    // werden alle Geometrien der Zielobjekte des Fremdschlüssels auf der Karte angezeigt
    // (mit Ausnahme der Geometrie jenes Zielobjekts des Fremdschlüssels, das gerade ausgewählt ist
    // und somit ohnehin schon auf der Karte angezeigt wird)
    $('.value-assigner').parent('span').click(function () {
      let valueAssigner = $(this).children();
      let foreignModel = valueAssigner.data('foreign-model');
      let fieldName = valueAssigner.data('field-name');
      let url = "{% url 'datenmanagement:'|add:model_name|add:'_geometry' %}";
      let modelName = '{{ model_name }}';
      let pattern = new RegExp(modelName);
      url = url.replace(pattern, foreignModel);
      currMap.loadGeometryFromForeignKeyFieldObjects(
        url,
        foreignModel,
        fieldName,
        valueAssigner.data('field-title'),
        '',
        $('select[name=' + fieldName + ']').find(':selected').val(),
        false
      );
      disableValueAssigner(valueAssigner);
    });

    {% if gpx_input %}
      // bei Auswahl einer Datei im GPX-Upload-Feld wird dessen Label mit dem Namen der Datei überschrieben
      // und die ausgewählte GPX-Datei zum Server geschickt; als Antwort des Servers wird der Inhalt der GPX-Datei
      // als GeoJSON mit den zusätzlichen Attributen mit Start- und Endzeitpunkt erwartet;
      // diese Attribute werden nach dem erfolgreichen Empfangen der Antwort des Servers in die dafür vorgesehenen Input-Felder geschrieben
      // und die Geometrie auf die Karte gezeichnet
      $('#id_gpx').change(function (e) {
        toggleModal(
          $('#loading-modal'),
          'Auswerten der GPX-Datei',
          'Die GPX-Datei wird zum Server hochgeladen und ausgewertet. Dies kann einen Moment dauern.'
        );
        let file = e.target.files[0];
        let formData = new FormData();
        formData.append('gpx', file);
        // Leaflet-Geoman-Layer von Karte entfernen (falls zuvor schon eine GPX-Datei hochgeladen wurde)
        currMap.pm.getGeomanLayers().forEach((layer) => {
          if (!layer.toGeoJSON().properties.foreignkey) {
            layer.remove();
          }
        });
        // Upload der GPX-Datei und Warten auf Antwort des Servers
        fetch(
          '{% url "datenmanagement:gpxtogeojson" %}', {
            method: 'POST',
            body: formData,
          }
        ).then(
          (response) => {
            return response.json();
          }
        ).then(
          (data) => {
            // falls Fehler bei der Kommunikation mit FME Server auftrat...
            if (data.status_code) {
              // Ausgabe der Fehlermeldung
              console.log('Fehler bei Kommunikation mit FME Server');
              console.log(data.error_log);
              // ansonsten...
            } else {
              // Start- und Endzeitpunkt aus GeoJSON auslesen und in die dafür vorgesehenen Input-Felder schreiben
              $('#id_startzeitpunkt').val(data.features[0].properties.startzeitpunkt.slice(0, 19));
              $('#id_endzeitpunkt').val(data.features[0].properties.endzeitpunkt.slice(0, 19));
              // Layer erzeugen
              let track = new L.geoJSON(data, {
                color: 'red'
              });
              // erzeugten Layer und alle Sublayer zu Leaflet-Geoman-Draw-Layer hinzufügen
              track._changeGeom = true;
              track.eachLayer((layer) => {
                layer._drawnByGeoman = true;
              });
              // Leaflet-Geoman-Draw-Layer zur Karte hinzufügen
              track.addTo(currMap);
            }
            toggleModal($('#loading-modal'));
          }
        ).catch(
          (error) => {
            refreshModal(
              $('#loading-modal'),
              'Fehler bei Kommunikation mit Server',
              'Es ist ein Fehler bei der Kommunikation mit dem Server aufgetreten. Bitte versuchen Sie es erneut oder kontaktieren Sie einen Administrator.',
              true
            );
            console.error(error);
          }
        );
      });
    {% endif %}

    {% if postcode_assigner %}
      // beim Klick auf das Icon für die automatische Zuweisung einer Postleitzahl wird der Server entsprechend angefragt;
      // als Antwort des Servers wird ein GeoJSON mit einem Attribut mit der Postleitzahl erwartet;
      // dieses Attribute wird nach dem erfolgreichen Empfangen der Antwort des Servers in das dafür vorgesehene Input-Feld geschrieben
      // und die Geometrie auf die Karte gezeichnet
      $('#postcode-assigner').parent('span').click(function () {
        let geoJson = currMap.pm.getGeomanLayers()[0].toGeoJSON();
        let geometryType = '{{ geometry_type|lower }}';
        if (geometryType.indexOf('point') !== -1)
          geometryType = 'Point';
        else if (geometryType.indexOf('line') !== -1)
          geometryType = 'LineString';
        else
          geometryType = 'Polygon';
        let ort = getFeatureCenter(geoJson, geometryType);
        // Anfragen des Servers und Warten auf Antwort des Servers
        let params = {
          search_class: 'postcode_areas',
          x: ort[0],
          y: ort[1]
        };
        let query = Object.keys(params).map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k])).join('&');
        let url = '{% url "toolbox:reversesearch" %}' + '?' + query;
        fetch(
            url
        ).then(
          (response) => {
            return response.json();
          }
        ).then(
          (data) => {
            if (data.features[0].properties.postleitzahl && typeof data.features[0].properties.postleitzahl == 'string')
              $('#postcode-assigner').parent().parent().next().find('input').val(data.features[0].properties.postleitzahl);
          }
        ).catch(
          (error) => {
            console.error(error);
            toggleModal(
              $('#error-modal'),
              'Fehler bei Zuweisung einer Postleitzahl',
              'Es ist ein Fehler bei der automatischen Zuweisung einer Postleitzahl aufgetreten. Bitte versuchen Sie es erneut oder kontaktieren Sie einen Administrator.'
            );
          }
        );
      });
    {% endif %}
  </script>
{% endblock %}
