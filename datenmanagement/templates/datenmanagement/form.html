{% extends "navbar.html" %}
{% load datenmanagement_tags %}
{% load guardian_tags %}
{% load leaflet_tags %}
{% load static %}

{% block title %}Formular | {% endblock %}

{% block style %}
  {{ block.super }}
  {% leaflet_css plugins="geoman,locatecontrol" %}
  <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/dataform.css' %}" />
  {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/dataform-mobile.css' %}" />
  {% else %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/dataform-desktop.css' %}" />
  {% endif %}
{% endblock %}

{% block scripts %}
  {{ block.super }}
  {% leaflet_js plugins="geoman,locatecontrol" %}
  <script type="text/javascript" src="{% static 'proj4/proj4.js' %}"></script>
  <script type="text/javascript" src="{% static 'wicket/wicket.js' %}"></script>
  <script type="text/javascript" src="{% static 'wicket/wicket-leaflet.js' %}"></script>
  <script type="text/javascript" src="{% static 'proj4leaflet/proj4leaflet.js' %}"></script>
  <script type="module" src="{% static 'martinez-polygon-clipping/martinez.min.js' %}"></script>
  <script type="module" src="{% static 'datenmanagement/js/leafletHelpers.js' %}"></script>
  <script type="text/javascript" src="{% static 'datenmanagement/js/generics.js' %}"></script>
{% endblock %}

{% block content %}
  {% if form.errors %}
    {% for field in form %}
      {% if field.errors %}
        {% for error in field.errors %}
          <div class="alert alert-danger" role="alert">
            {% autoescape off %}
              {{ error }}
            {% endautoescape %}
          </div>
        {% endfor %}
      {% endif %}
    {% endfor %}
    {% if form.non_field_errors %}
      {% for error in form.non_field_errors %}
        <div class="alert alert-danger" role="alert">
          {{ error|customize_error_message }}
        </div>
      {% endfor %}
    {% endif %}
    <div class="mb-4"></div>
  {% endif %}
  {% if associated_new %}
    <div class="alert alert-primary" role="alert">
      <h5 class="alert-heading">assoziierte Datensätze</h5>
      {% if object and associated_objects %}
        <ul>
          {% for associated_object in associated_objects %}
            <li>{{ associated_object.title }} {{ associated_object.name }} <a href="{{ associated_object.link }}" target="_blank" title="{{ associated_object.title }} ansehen oder bearbeiten"><i class="fas fa-arrow-up-right-from-square"></i></a></li>{% if associated_object.preview_img_url %} <a href="{{ associated_object.preview_img_url }}" target="_blank" title="große Ansicht öffnen…"><img src="{% if associated_object.preview_thumb_url %}{{ associated_object.preview_thumb_url }}{% else %}{{ associated_object.preview_img_url }}{% endif %}" alt="Vorschau" width="50px" /></a>{% endif %}
          {% endfor %}
        </ul>
      {% else %}
        (noch) keine assoziierten Datensätze vorhanden
      {% endif %}
      {% if user|user_has_object_change_permission:object %}
        <hr/>
        {% for associated_new_entry in associated_new %}
          <p class="{% if forloop.last %}mb-1{% else %}mb-3{% endif %}">
            <a class="btn btn-primary" role="button" href="{{ associated_new_entry.link }}" target="_blank"><i class="fas fa-arrow-up-right-from-square"></i> {{ associated_new_entry.title }} anlegen</a>
          </p>
        {% endfor %}
      {% endif %}
    </div>
    <div class="mb-4"></div>
  {% endif %}
	<form class="form" role="form" method="post" enctype="multipart/form-data" action="">
  {% csrf_token %}
    <div {% if geometry_type %}id="custom-form"{% endif %}>
      <table class="table table-striped">
        {% for field in form %}
          {% if not field|is_field_address_related_field and not field|is_field_geometry_field %}
            <tr>
              <td>
                {% if field.name in catalog_link_fields_names %}
                  {{ field.label_tag }} <small>(<a href="{{ catalog_link_fields|get_dict_value_by_key:field.name }}"><i class="fas fa-circle-info"></i> ALKIS-Katalog</a>)</small>
                {% elif field|is_field_hours_related_field %}
                  {{ field.label_tag }} <small>(<a href="{% static 'hilfe/work/datensatz-anlegen.html' %}#datensatz-anlegen-oeffnungszeiten"><i class="fas fa-circle-question"></i> Hilfe</a>)</small>
                {% elif fields_with_foreign_key_to_linkify and field.name in fields_with_foreign_key_to_linkify %}
                  {% if object and user|user_has_object_change_permission:object %}
                    {% with foreign_model=object|get_value_of_field:field.name|get_class_name %}
                      {{ field.label_tag }} <a href="{% url 'datenmanagement:'|add:foreign_model|add:'change' field.value %}" id="link_{{ field.name }}"> <i class="fas fa-arrow-up-right-from-square" title="{{ field.label }} ansehen oder bearbeiten"></i></a>
                    {% endwith %}
                  {% else %}
                    {% with foreign_model=field.name|get_foreign_key_field_class_name:model_name %}
                      {{ field.label_tag }} <a hidden href="{% url 'datenmanagement:'|add:foreign_model|add:'change' '' %}" id="link_{{ field.name }}"> <i class="fas fa-arrow-up-right-from-square" title="{{ field.label }} ansehen oder bearbeiten"></i></a>
                    {% endwith %}
                  {% endif %}
                {% elif postcode_assigner and field.name == postcode_assigner %}
                  {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_object_change_permission:object %}
                    {{ field.label_tag }} <span><i id="postcode_assigner" class="fas fa-gears text-{% if geometry %}success enabled{% else %}black-50{% endif %}"{% if geometry %} title="Postleitzahl automatisch zuweisen"{% endif %}></i></span>
                  {% endif %}
                {% else %}
                  {{ field.label_tag }}
                {% endif %}
              </td> 
              {% autoescape off %}
                <td>
                  {{ field }}
                </td>
              {% endautoescape %}
            </tr>
          {% endif %}
        {% endfor %}
        {% if gpx_input %}
          <tr>
            <td>
              <label for="id_gpx" class="required">GPX-Datei</label>
            </td>
            <td>
              <div class="custom-file">
                <input class="form-control" type="file" id="id_gpx" name="gpx" accept=".gpx">
              </div>
            </td>
          </tr>
        {% endif %}
      </table>
    </div>
    {% if geometry_type %}
      <div id="map-adresssearch-container-form">
        {% if geometry %}
          <textarea hidden id="id_geometrie" class="required django-leaflet-raw-textarea" name="geometrie" cols="150" rows="4">{{ geometry }}</textarea>
        {% else %}
          <textarea hidden id="id_geometrie" class="required django-leaflet-raw-textarea" name="geometrie" cols="150" rows="4">{ "type": "{{ geometry_type }}", "coordinates": [] }</textarea>
        {% endif %}
        {% leaflet_map "id_geometrie-map" callback="id_geometrie_map_callback" %}
        {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_object_change_permission:object %}
          {% if geometry_type == 'Point' or address_type and not address_mandatory %}
            <div class="d-grid mt-3 gap-2 d-md-block">
              {% if geometry_type == 'Point' %}
                <button disabled id="addressToMap" class="btn btn-success" type="button"><i class="fas fa-location-dot"></i> Marker setzen</button>
              {% endif %}
              {% if not address_mandatory %}
                {% if address_type == 'Adresse' %}
                  <button disabled id="mapToAddress" class="btn btn-success" type="button"><i class="fas fa-house"></i> Adresse übernehmen</button>
                {% elif address_type == 'Straße' %}
                  <button disabled id="mapToStreet" class="btn btn-success" type="button"><i class="fas fa-road"></i> Straße übernehmen</button>
                {% endif %}
              {% endif %}
            </div>
          {% endif %}
        {% endif %}
        <div class="mt-3">
          {% if address_type %}
            {% if address_type == 'Adresse' %}
              <label for="id_adresse" class="form-label{% if address_mandatory %} required{% endif %}">Adresse</label>
              <div class="form-floating">
                {{ form.adresse }}
                <label for="id_adresse">Adresse eingeben…</label>
              </div>
              <input id="id_adresse_uuid" type="hidden" name="adresse_uuid" value="{% if current_address %}{{ current_address }}{% endif %}">
            {% elif address_type == 'Straße' %}
              <label for="id_strasse" class="form-label{% if address_mandatory %} required{% endif %}">Straße</label>
              <div class="form-floating">
                {{ form.strasse }}
                <label for="id_strasse">Straße eingeben…</label>
              </div>
              <input id="id_strasse_uuid" type="hidden" name="strasse_uuid" value="{% if current_street %}{{ current_street }}{% endif %}">
            {% endif %}
          {% else %}
            {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_object_change_permission:object %}
              <label for="id_address_search" class="form-label">Adressensuche</label>
              <div class="form-floating">
                <input id="id_address_search" type="text" class="form-control" name="address_search" autocapitalize="off" autocomplete="off" placeholder="Adresse, Straße oder Gemeindeteil eingeben…">
                <label for="id_address_search">Adresse, Straße oder Gemeindeteil eingeben…</label>
              </div>
            {% endif %}
          {% endif %}
          <div id="results-container" class="results"></div>
        </div>        
      </div>
    {% endif %}
    <div id="buttons">
      <div class="d-grid mt-5 mb-3 gap-2 d-md-block">
        {% if not object and user|user_has_model_add_permission:model_name_lower or object and user|user_has_object_change_permission:object %}
          <button class="btn btn-success" type="submit" onclick="setAddressUuid();"><i class="fas fa-floppy-disk"></i> speichern</button>
        {% endif %}
        {% if object and user|user_has_model_delete_permission:model_name_lower and user|user_has_object_delete_permission:object %}
          <a class="btn btn-danger" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'delete' object.pk %}"><i class="fas fa-trash"></i> löschen</a>
        {% endif %}
        <a class="btn btn-warning" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'start' %}"><i class="fas fa-hand"></i> abbrechen</a>
      </div>
    </div>
    {% if address_type %}
      <div id="{% if address_type == 'Adresse' %}maptoaddress{% elif address_type == 'Straße' %}maptostreet{% endif %}-error-modal" class="modal fade" tabindex="-1" aria-labelledby="{% if address_type == 'Adresse' %}maptoaddress{% elif address_type == 'Straße' %}maptostreet{% endif %}-error-modal-label" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header" id="{% if address_type == 'Adresse' %}maptoaddress{% elif address_type == 'Straße' %}maptostreet{% endif %}-error-modal-header">
              <h5 class="modal-title">Keine automatische Zuordnung einer {{ address_type }} möglich!</h5>
            </div>
            <div class="modal-body">
              Bitte setzen Sie den Marker bzw. zeichnen Sie die Linie oder Fläche in der Karte {{ REVERSE_SEARCH_RADIUS }} m oder dichter an die nächste {{ address_type }} heran.
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
            </div>
          </div>
        </div>
      </div>
    {% endif %}
    {% if gpx_input %}
      <div id="id_gpxLoading" class="modal fade" tabindex="-1" aria-labelledby="id_gpxLoading-label" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header" id="id_gpxLoading-header">
              <h5 class="modal-title" id="id_gpxLoading-title">Auswerten der GPX-Datei</h5>
            </div>
            <div class="modal-body" id="id_gpxLoading-body">
              Die GPX-Datei wird zum Server hochgeladen und ausgewertet. Dies kann einen Moment dauern.
              <div class="text-center">
                <div class="spinner-border m-4 text-primary" role="status">
                  <span class="sr-only">laden…</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    {% endif %}
    {% if postcode_assigner %}
      <div id="id_postcodeAssigning" class="modal fade" tabindex="-1" aria-labelledby="id_postcodeAssigning-label" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header" id="id_postcodeAssigning-header">
              <h5 class="modal-title" id="id_postcodeAssigning-title">Fehler bei Zuweisung einer Postleitzahl</h5>
            </div>
            <div class="modal-body" id="id_postcodeAssigning-body">
              Es ist ein Fehler bei der automatischen Zuweisung einer Postleitzahl aufgetreten. Bitte versuchen Sie es erneut oder kontaktieren Sie einen Administrator.
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
            </div>
          </div>
        </div>
      </div>
    {% endif %}
	</form>
  <script type="text/javascript">
    // globale Variablen
    let FEATURE_GEOMETRY = []; // wird in showResults() befüllt

    // Marker für Leaflet konfigurieren
    let redMarker = new L.Icon({
      iconUrl: '{% static "datenmanagement/img/leaflet-markers/marker-red.svg" %}',
      shadowUrl: '{% static "datenmanagement/img/leaflet-markers/marker-shadow.png" %}',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    function id_geometrie_map_callback(map, options) {
      // Karte auch in anderen JavaScript-Funktionen verfügbar machen
      window.currMap = map;

      // Standard-Zoom-Kontrollelemente entfernen und durch solche mit eigenen Tooltips ersetzen
      map.zoomControl.remove();
      L.control.zoom({
        zoomInTitle:'hineinzoomen',
        zoomOutTitle:'herauszoomen'
      }).addTo(map);

      {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
        // bei mobilen Geräten: Standortbestimmung hinzufügen
        L.control.locate({
          drawCircle: false,
          drawMarker: false,
          flyTo: true,
          locateOptions: {
            enableHighAccuracy: true
          },
          setView: 'untilPan',
          strings: {
            title: 'Standortbestimmung'
          }
        }).addTo(map);
      {% endif %}

      // Einige Konstanten und Variablen initialisieren und definieren
      map._wmsFormat = 'image/png';
      map._maxLayerZoom = 19;
      map._minLayerZoom = 13;
      map._themaUrl = {};

      // EPSG:25833 definieren
      proj4.defs([
        ['EPSG:25833', '+proj=utm +zone=33 +ellps=WGS84 +towgs84=0,0,0,0,0,0,1 +units=m +no_defs'],
      ]);

      /*
       * Leaflet-Geoman Konfigurationen
       */
       // eigene Übersetzungen definieren
      const customTranslation = {
        actions: {
          cancel: 'abbrechen',
          finish: 'beenden',
          removeLastVertex: 'letzten Stützpunkt löschen',
        },
        buttonTitles: {
          cutButton: 'Teile aus vorhandenen Kartenobjekten ausschneiden',
          deleteButton: 'vorhandene Kartenobjekte löschen',
          dragButton: 'vorhandene Kartenobjekte verschieben',
          drawLineButton: 'Linie zeichnen',
          drawMarkerButton: 'Marker (neu) setzen',
          editButton: 'vorhandene Kartenobjekte bearbeiten',
        },
        tooltips: {
          continueLine: 'klicken, um weiteren Stützpunkt zu setzen',
          finishLine: 'weitere Stützpunkte setzen oder auf beliebigen Stützpunkt klicken, um Linie abzuschließen',
          finishPoly: 'weitere Stützpunkte setzen oder auf ersten Stützpunkt klicken, um Polygon abzuschließen',
          finishRect: 'klicken, um Rechteck abzuschließen',
          firstVertex: 'klicken, um ersten Stützpunkt zu setzen',
          placeMarker: 'klicken, um Marker zu setzen',
        },
      };

      map.pm.setLang('customDe', customTranslation, 'de');   // Tooltip-Sprache mit eigenen Übersetzungen setzen

      map.pm.setPathOptions({
        color: 'red',               // Farbe für gezeichnete Objekte
        fillColor: 'red',           // Füllfarbe für gezeichnete Objekte
        requireSnapToFinish: true,  // Zeichnen von Polygonen endet mit bestehendem Punkt
        templineStyle: {
          color: 'red',             // Farbe während des zeichnens
        },
      });

      map.pm.setGlobalOptions({
        snapDistance: 10,
        continueDrawing: false,   // Nach Hinzufügen einer Geometrie
        markerStyle: {
          icon: redMarker,
        }
      })

      {% if geometry_type == 'Point' %}
        // Leaflet-Geoman controls zur Map hinzufügen
        map.pm.addControls({
          position: 'topleft',
          drawCircleMarker: false,  // Punktueller Kreis
          drawCircle: false,        // Kreis
          drawPolyline: false,      // Linie
          drawRectangle: false,     // Rechteck
          drawPolygon: false,       // Polygon
          drawText: false,          // Text
          dragMode: false,          // Verschieben deaktivieren
          editMode: false,          // Editieren des Punktes deaktivieren
          cutPolygon: false,        // Polygon aus anderer Geometrie ausschneiden
          rotateMode: false,        // Geometrie rotieren
          removalMode: false,       // Entfernen von Layern deaktivieren
        });
      {% elif 'LineString' in geometry_type and model_name != 'Fallwildsuchen_Nachweise' %}
        // Leaflet-Geoman controls zur Map hinzufügen
        map.pm.addControls({
          position: 'topleft',
          drawCircleMarker: false,  // Punktueller Kreis
          drawCircle: false,        // Kreis
          drawMarker: false,        // Marker
          drawRectangle: false,     // Rechteck
          drawPolygon: false,       // Polygon
          drawText: false,          // Text
          dragMode: false,          // Verschieben deaktivieren
          cutPolygon: false,        // Polygon aus anderer Geometrie ausschneiden
          rotateMode: false,        // Geometrie rotieren
        });
      {% elif geometry_type == 'Polygon' %}
        // Leaflet-Geoman controls zur Map hinzufügen
        map.pm.addControls({
          position: 'topleft',
          drawCircleMarker: false,  // Punktueller Kreis
          drawCircle: false,        // Kreis
          drawMarker: false,        // Marker
          drawPolyline: false,      // Linie
          drawText: false,          // Text
          dragMode: false,          // Verschieben deaktivieren
          cutPolygon: false,        // Polygon aus anderer Geometrie ausschneiden
          rotateMode: false,        // Geometrie rotieren
        });
      {% elif geometry_type == 'MultiPolygon' %}
        // Leaflet-Geoman controls zur Map hinzufügen
        map.pm.addControls({
          position: 'topleft',
          drawCircleMarker: false,  // Punktueller Kreis
          drawCircle: false,        // Kreis
          drawMarker: false,        // Marker
          drawPolyline: false,      // Linie
          drawText: false,          // Text
          dragMode: false,          // Verschieben deaktivieren
          rotateMode: false,        // Geometrie rotieren
        });
      {% else %}
        // Leaflet-Geoman controls zur Map hinzufügen
        map.pm.addControls({
          position: 'topleft',
          drawCircleMarker: false,  // Punktueller Kreis
          drawCircle: false,        // Kreis
          drawMarker: false,        // Marker
          drawPolyline: false,      // Linie
          drawRectangle: false,     // Rechteck
          drawPolygon: false,       // Polygon
          drawText: false,          // Text
          dragMode: false,          // Verschieben deaktivieren
          editMode: false,          // Editieren des Punktes deaktivieren
          cutPolygon: false,        // Polygon aus anderer Geometrie ausschneiden
          rotateMode: false,        // Geometrie rotieren
          removalMode: false,       // Entfernen von Layern deaktivieren
        });
      {% endif %}
      {% if 'Polygon' in geometry_type %}
        // adoptGeometry-Button bei Polygonen und MultiPolygonen hinzufügen
        map.pm.Toolbar.createCustomControl({
          name: 'adoptGeometry',
          title: 'vorhandene Geometrien adoptieren',
          block: 'edit',
          className: 'adopt-geometry-control',
          actions: [
            // default 'finish' action
            'finishMode',
          ],
        });
        map.on('pm:buttonclick', (e) => {
          // Geometrien Interaktive setzen
          if (e.btnName === 'adoptGeometry' && e.button.toggleStatus === false) {
            map.getLayersOfType(type = 'Polygon', withCompatible = true).forEach((layer) => {
              layer.setInteractive(true);
              layer.on('click', () => {
                let j = JSON.parse($('#id_geometrie').val());
                if (j.type.indexOf('MultiPolygon') > -1){
                  map.pm.getGeomanDrawLayers()[0].unite(layer, 'MultiPolygon');
                } else {
                  map.pm.getGeomanDrawLayers()[0].unite(layer, 'Polygon');
                }
              });
            });
          }
        });
        map.on('pm:buttonclick', (e) => {
          // Bearbeitung deaktivieren
          if (e.btnName === 'adoptGeometry' && e.button.toggleStatus === true){
            map.pm.getGeomanLayers().forEach((lay) => {
              lay.setInteractive(interactive=false);
            });
          }
        });
        map.on('pm:actionclick', (e) => {
          // Bearbeitung deaktivieren
          if (e.btnName === 'adoptGeometry' && e.text === 'beenden'){
            map.pm.getGeomanLayers().forEach((lay) => {
              lay.setInteractive(interactive=false);
            });
          }
        });
      {% endif %}

      /*
       * Definition der Hintergrundkarten
       */

      // Standard-Layer: ORKa.MV
      const orkamv =  L.tileLayer('https://www.orka-mv.de/geodienste/orkamv/tiles/1.0.0/orkamv/GLOBAL_WEBMERCATOR/{z}/{x}/{y}.png', {
        maxZoom: map._maxLayerZoom,
        attribution: 'Kartenbild © Hanse- und Universitätsstadt Rostock (<a href="http://creativecommons.org/licenses/by/4.0/deed.de" target="_blank">CC BY 4.0</a>)<br>Kartendaten © <a href="http://www.openstreetmap.org" target="_blank">OpenStreetMap</a> (<a href="http://opendatacommons.org/licenses/odbl" target="_blank">ODbL</a>) und LkKfS-MV'
      });

      // ORKa.MV standardmäßig zur Karte hinzufügen
      map.addLayer(orkamv);

      // OpenStreetMap
      const osm =  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: map._maxLayerZoom,
        attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap-Mitwirkende</a>'
      });

      // basemap.de
      const basemapde = L.tileLayer.wms('https://sgx.geodatenzentrum.de/wms_basemapde', {
        layers: 'de_basemapde_web_raster_farbe',
        format: map._wmsFormat,
        maxZoom: map._maxLayerZoom,
        attribution: '© GeoBasis-DE/BKG'
      });

      // Liegenschaftskarte
      const liegenschaftskarte = L.tileLayer.wms('{% url "datenmanagement:owsproxy" %}' + '/liegenschaftskarte/wms', {
        layers: 'hro.liegenschaftskarte',
        format: map._wmsFormat,
        maxZoom: map._maxLayerZoom,
        attribution: '© Hanse- und Universitätsstadt Rostock (MLV intern)'
      });

      // Luftbild
      const luftbild =  L.tileLayer('{% url "datenmanagement:owsproxy" %}' + '/luftbild_mv-20/tiles/1.0.0/hro.luftbild_mv-20.luftbild_mv-20/GLOBAL_WEBMERCATOR/{z}/{x}/{y}.png', {
        maxZoom: map._maxLayerZoom,
        attribution: '© GeoBasis-DE/M-V'
      });

      // Kilometerquadrate ETRS89/UTM-33N
      const kilometerquadrate = L.tileLayer.wms('https://geo.sv.rostock.de/geodienste/koordinatensysteme/wms', {
        layers: 'hro.koordinatensysteme.kilometerquadrate_utm',
        format: map._wmsFormat,
        maxZoom: map._maxLayerZoom,
        transparent: true
      });

      // definierte Karten als Hintergrundkarten zusammenfassen
      const baseMaps = {
        'basemap.de': basemapde,
        'Liegenschaftskarte': liegenschaftskarte,
        'Luftbild': luftbild,
        'OpenStreetMap': osm,
        'ORKa.MV': orkamv
      };

      // definierte Karten als Overlay-Karten zusammenfassen
      let overlayMaps = {
        'Kilometerquadrate ETRS89/UTM-33N': kilometerquadrate
      };


      /*
       * zusätzliche WMS-Layer definieren und als Overlay-Karten hinzufügen
       */
      {% if additional_wms_layers %}
        {% for additional_wms_layer in additional_wms_layers %}
          let overlayMap = L.tileLayer.wms('{{ additional_wms_layer.url }}', {
            layers: '{{ additional_wms_layer.layers }}',
            format: map._wmsFormat,
            maxZoom: map._maxLayerZoom,
            transparent: true
          });
          overlayMaps['{{ additional_wms_layer.title }}'] = overlayMap;
        {% endfor %}
      {% endif %}

      // Control-Menü für Hintergrundkarten zur Map hinzufügen
      L.control.layers(baseMaps,overlayMaps).addTo(map);


      /*
       * Im Change View Geometrie auf Karte anzeigen
       */
      {% if geometry %}
        map.loadGeometryFromField('#id_geometrie')
      {% endif %}


      {% if model_name != 'Fallwildsuchen_Nachweise' %}
        /*
         * Zusätzliche Datenthemen anbieten
         */

        // Füge zweiten Layer-Control Button ein zum Anzeigen von Datensätzen
        let dataLayerControl = new L.control.layers({}, {}).addTo(map);

        // iteriere durch alle Datenthemen
        {% for key, value in model_list.items %}
          {% with datenthema_name_lower=key|lower %}
            map._themaUrl = {...map._themaUrl, '{{ value }}': '{% url 'datenmanagement:'|add:key|add:'geometry' %}'};
            // GeoJson-Projektions-Layer initialisieren
            let {{ datenthema_name_lower }} = new L.Proj.geoJson();
            // leeres GeoJson-Projektions-Layer zur Layercontrol hinzufügen
            dataLayerControl.addOverlay({{ datenthema_name_lower }}, '{{ value }}')
            // Beim hinzufügen des Layers Daten laden
            {{ datenthema_name_lower }}.on('add', function () {
              if (map.getZoom() > map._minLayerZoom) {
                // Daten zum entsprechenden Layer hinzufügen
                map.loadExternalData(
                  '{% url 'datenmanagement:'|add:key|add:'geometry' %}',
                  this
                );

                map.eachLayer((layer) => {
                  // 'Anheben' des Layers, welches bearbeitet wird
                  if (layer._drawnByGeoman === true){
                    if (layer instanceof L.Marker){
                      layer.setZIndexOffset(1000);
                    } else {
                      layer.bringToFront();
                    }
                  }
                });
              }
            });
          {% endwith %}
        {% endfor %}


        /*
         * Beim Bewegen der Karte updateMap() ausführen
         */
        map.on('moveend', () => {
          map.updateMap(dataLayerControl);
        });
        map.on('zoomend', () => {
          map.updateMap(dataLayerControl);
        })
      {% endif %}


      /**
       * @function
       *
       * Beim Start des Modus 'Zeichnen' überprüfen, ob es bereits Geoman-Layer gibt.
       * Falls ja, lösche diese.
       *
       * @param e
       */
      map.on('pm:drawstart', function(e) {
        {% if geometry_type == 'Point' or geometry_type == 'LineString' or geometry_type == 'Polygon' %}
          if (map.pm.getGeomanLayers().length > 0){
            map.pm.getGeomanLayers().forEach((item) => {
              if (item._drawnByGeoman === true){
                map.removeLayer(item);
              }
            })
          }
        {% endif %}
      });


      {% if address_type %}
        /**
         * Wenn Datenmodell Adressbezug vorsieht und dies ein Pflichangabe ist,
         * wird beim Hinzufügen oder Editieren einer Geometrie die Addresse
         * oder die Straße gesetzt und es wird die Postleitzahl-Auto-Zuweisung
         * aktiviert.
         *
         * @param layer
         */
        map.on('pm:create', function ({layer}) {
          {% if address_mandatory %}
            // Adressenbezug setzen für gesetze Geometrie
            setAddressOrStreet('{{ address_type }}', layer);
            {% if geometry_type == "Point" %}
              // Bei Bewegungs-Event (nur bei Markern) setze Adresse neu
              layer.on('pm:dragend', (e) => {
                setAddressOrStreet('{{ address_type }}', e.layer);
              });
            {% else %}
              // Bei Bewegungs-Event (nur bei Markern) setze Adresse neu
              layer.on('pm:update', (e) => {
                setAddressOrStreet('{{ address_type }}', e.layer);
              });
            {% endif %}
            $('#postcode_assigner').removeClass('text-black-50');
            $('#postcode_assigner').addClass('text-success enabled');
            $('#postcode_assigner').attr('title', 'Postleitzahl automatisch zuweisen');
          {% else %}
            $('#addressToMap').prop('disabled', false);
            $('#mapToAddress').prop('disabled', false);
            $('#mapToStreet').prop('disabled', false);
          {% endif %}
        });
      {% endif %}
    }


    $(document).ready(function() {
      // falls Gruppe von Benutzern gesetzt ist, die für das Feld Ansprechpartner/Bearbeiter in einer entsprechenden Auswahlliste genutzt werden sollen:
      // Auswahlfeld Ansprechpartner/Bearbeiter in normales Feld umwandeln...
      {% if group_with_users_for_choice_field %}
        // ...falls Benutzer kein Änderungsrecht am Datensatz hat
        {% if not user|user_has_object_delete_permission:object %}
          {% for field in form %}
            {% if field.name == 'ansprechpartner' or field.name == 'bearbeiter' %}
              let value = '';
              {% if field.name == 'ansprechpartner' %}
                value = '{{ object.ansprechpartner }}';
              {% endif %}
              {% if field.name == 'bearbeiter' %}
                value = '{{ object.bearbeiter }}';
              {% endif %}
              var inputField = $('<input>').attr({
                id: 'id_' + '{{ field.name }}',
                type: 'text',
                name: '{{ field.name }}',
                value: value
              });
              $('select#id_' + '{{ field.name }}').replaceWith(inputField);
            {% endif %}
          {% endfor %}
        {% endif %}
      {% endif %}

      // Checkboxen in Multiple-Choice-Feldern an Bootstrap 5 anpassen
      $('ul input[type="checkbox"]').each(function () {
          $(this).addClass('form-check-input');
      });


      // Read-only-Felder behandeln
      {% if readonly_fields %}
        {% for field in readonly_fields %}
          var inputField = $('input#id_' + '{{ field }}');
          {% if user|user_has_object_change_permission:object %}
            if (!inputField.val()) {
              inputField.closest('tr').hide();
            } else {
              let wert = inputField.val();
              if (inputField.attr('type') == 'date') {
                let datum = new Date(inputField.val());
                wert = datum.toLocaleDateString('de-DE', options = {day: '2-digit', month: '2-digit', year: 'numeric'});
              }
              inputField.parent().append('<span id="' + inputField.attr('id') + '" title="nicht editierbar – automatisch vergeben"><em>' + wert + '</em></span>');
              let label = inputField.parent().closest('tr').find('label');
              label.wrapInner('<em></em>');
              inputField.hide();
            }
          {% else %}
            inputField.closest('tr').hide();
          {% endif %}
        {% endfor %}
      {% endif %}

      // alle Felder deaktivieren, falls Benutzer kein Änderungsrecht am Datensatz hat
      {% if not user|user_has_object_change_permission:object %}
        $('input').each(function () {
            $(this).prop('disabled', true);
        });
        $('select').each(function () {
            $(this).prop('disabled', true);
        });
        $('textarea').each(function () {
            $(this).prop('disabled', true);
        });
      {% endif %}

      // Multi-Datei-Feld behandeln
      let fotoField = $('input#id_foto');
      if (fotoField.length) {
        fotoField.attr('accept', 'image/*');
        {% if multi_foto_field %}
          if (fotoField[0].files.length === 0) {
            fotoField.attr('multiple', 'multiple');
          }
        {% endif %}
      }

      let pdfField = $('input#id_pdf');
      if (pdfField.length) {
        pdfField.attr('accept', 'application/pdf');
      }

      // Adressensuche initialisieren

      results = $('div.results');
      {% if address_type %}
        {% if address_type == 'Adresse' %}
          let searchField = $('#id_adresse');
        {% elif address_type == 'Straße' %}
          searchField = $('#id_strasse');
        {% endif %}
      {% else %}
        searchField = $('#id_address_search');
      {% endif %}

      results.click(function(event) {
        $('html').one('click',function() {
          results.children().remove();
          results.fadeOut();
        });
        event.stopPropagation();
      });

      searchField.keyup(function() {
        if ($(this).val().length >= 3) {
          let searchText = searchField.val();
          let url = '{% url "datenmanagement:addresssearch" %}';
          fetch(url + '?query=' + searchText, {
            method: 'GET'
          })
          .then(response => response.json())
          .then(data => showResults(data))
          .catch(error => console.log(error))
        } else {
          results.children().remove();
          results.fadeOut();
        }
      });

      {% if address_type %}
        {% if address_type == 'Adresse' %}
          $('#id_adresse').on('click', function() {
            $(this).val('');
            $('#id_adresse_uuid').val('');
            $('#results-container').hide();
          })
        {% elif address_type == 'Straße' %}
          $('#id_strasse').on('click', function() {
            $(this).val('');
            $('#id_strasse_uuid').val('');
            $('#results-container').hide();
          })
        {% endif %}
      {% else %}
        $('#id_address_search').on('click', function() {
          $(this).val('');
          $('#results-container').hide();
        });
      {% endif %}

      // Butten: 'Marker setzen'
      $('#addressToMap').on('click', function() {
        getAddress(window.currMap);
        $('#mapToAddress').prop('disabled', false);
        $('#mapToStreet').prop('disabled', false);
      });

      // Button: 'Adresse setzen'
      $('#mapToAddress').on('click', function() {
        setAddressOrStreet('{{ address_type }}', window.currMap.pm.getGeomanLayers()[0]);
        $('#addressToMap').prop('disabled', false);
      });

      // Button: 'Straße setzen'
      $('#mapToStreet').on('click', function() {
        setAddressOrStreet('{{ address_type }}', window.currMap.pm.getGeomanLayers()[0]);
        $('#addressToMap').prop('disabled', false);
      });

      // verhindern, dass HTML5-/jQuery-Fehlermeldungen bei Pflichtfeldern die Django-Fehlermeldungen überdecken
      $('[required]').removeAttr('required');

      // vertikale Position der Buttons dynamisch setzen anhand von Position und Größe des Formulars (plus „Puffer“ von 20 Pixeln)
      {% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %}
        let top = $('#custom-form').position().top + $('#custom-form').height() + 20;
        $('#buttons').offset({
          top: top
        });
      {% endif %}

      // Labels für verpflichtende Boolean-Felder anpassen
      $('input[type="checkbox"]:not([value])').parent().parent().find('label').addClass('required');

      // Fremdschlüssellinks dynamisch anpassen je nach aktueller Auswahl in entsprechenden Auswahlfeldern (bei leerer Auswahl Link verstecken)
      {% if fields_with_foreign_key_to_linkify and user|user_has_object_change_permission:object or not object %}
        {% for field in fields_with_foreign_key_to_linkify %}
          $('select#id_' + '{{ field }}').each(function () {
            $(this).on('change', function() {
              let link = $('a#link_' + '{{ field }}');
              let href = link.prop('href');
              let value = $(this).find(':selected').val();
              if (value) {
                href = href.replace(/\/change\/.*/, '/change/' + value + '/');
                link.prop('href', href);
                link.prop('hidden', false);
              } else {
                link.prop('hidden', true);
              }
            });
          });
        {% endfor %}
      {% endif %}

      // Links auf vorhandene Fotos, PDF etc. immer in neuem Tab öffnen
      $('td').find('a').attr('title', 'in neuem Tab öffnen…');
      $('td').find('a').attr('target', '_blank');

      // Links auf vorhandene Fotos, PDF etc. sowie entsprechende Upload-Buttons mit ordentlichem Text versehen
      $('td').find('a').parent().contents().filter(function () {
        return this.nodeType == 3
      }).remove();
      $('td').find('a').parent().find('input[type="file"]').before('ändern in: ');
      $('<br>').insertBefore($('input[type="checkbox"][name$="-clear"]'));
      $('label[for$="-clear_id"]').addClass('label-with-margin');
      $('label[for$="-clear_id"]').text('löschen');

      // bestimmte Werte in Auswahllisten mit Kleinbuchstaben versehen
      $('td').find('option').each(function () {
        if ($(this).text() === 'Unbekannt')
          $(this).text('unbekannt');
        else if ($(this).text() === 'Ja')
          $(this).text('ja');
        else if ($(this).text() === 'Nein')
          $(this).text('nein');
      });
    });


    /**
     * Marker auf Adresse oder Straße aus Adressfeld setzen
     *
     * @param map - Leaflet Karte
     */
    function getAddress(map) {
      let x = 0;
      let y = 0;
      if (map.pm.getGeomanLayers().length > 0){
        let layer = map.pm.getGeomanLayers()[0];
        if (layer._drawnByGeoman && layer._latlng) {
          if (FEATURE_GEOMETRY.type === 'Point') {
            x = FEATURE_GEOMETRY.coordinates[0];
            y = FEATURE_GEOMETRY.coordinates[1];
          } else {
            x = FEATURE_GEOMETRY.coordinates[0][1][0] + ((FEATURE_GEOMETRY.coordinates[0][0][0] - FEATURE_GEOMETRY.coordinates[0][1][0]) / 2);
            y = FEATURE_GEOMETRY.coordinates[0][0][1] + ((FEATURE_GEOMETRY.coordinates[0][2][1] - FEATURE_GEOMETRY.coordinates[0][0][1]) / 2);
          }
          layer.setLatLng([y, x]);
        }
      } else {
        {% if geometry_type == "Point" %}
          if (FEATURE_GEOMETRY.type === 'Point') {
            x = FEATURE_GEOMETRY.coordinates[0];
            y = FEATURE_GEOMETRY.coordinates[1];
          } else {
            x = FEATURE_GEOMETRY.coordinates[0][1][0] + ((FEATURE_GEOMETRY.coordinates[0][0][0] - FEATURE_GEOMETRY.coordinates[0][1][0]) / 2);
            y = FEATURE_GEOMETRY.coordinates[0][0][1] + ((FEATURE_GEOMETRY.coordinates[0][2][1] - FEATURE_GEOMETRY.coordinates[0][0][1]) / 2);
          }
          let layer = new L.Marker([y, x],{icon: redMarker,});
          layer._drawnByGeoman = true; 
          layer.addTo(window.currMap); 
        {% endif %}
      }
    }


    /**
     * Liefert das Zentrum eines GeoJSON-Features zurück
     *
     * @param {JSON} json - GeoJSON
     */
    function getCenter(json) {
      let xArray = [];
      let yArray = [];
      let ort = [];
      {% if 'point' in geometry_type|lower %}
        ort = json.geometry.coordinates;
      {% elif 'line' in geometry_type|lower %}
        Array.min = function( array ){
          return Math.min.apply( Math, array );
        };
        Array.max = function( array ){
          return Math.max.apply( Math, array );
        };
        $.each(json.geometry.coordinates, function(index, value) {
          xArray.push(json.geometry.coordinates[index][0]);
          yArray.push(json.geometry.coordinates[index][1]);
        });
        ort[0] = Array.min(xArray) + ((Array.max(xArray) - Array.min(xArray)) / 2);
        ort[1] = Array.min(yArray) + ((Array.max(yArray) - Array.min(yArray)) / 2);
      {% elif 'polygon' in geometry_type|lower %}
        Array.min = function( array ){
          return Math.min.apply( Math, array );
        };
        Array.max = function( array ){
          return Math.max.apply( Math, array );
        };
        $.each(json.geometry.coordinates, function(index_outer, value_outer) {
          $.each(json.geometry.coordinates[index_outer], function(index_inner, value_inner) {
            xArray.push(json.geometry.coordinates[index_outer][index_inner][0]);
            yArray.push(json.geometry.coordinates[index_outer][index_inner][1]);
          });
        });
        ort[0] = Array.min(xArray) + ((Array.max(xArray) - Array.min(xArray)) / 2);
        ort[1] = Array.min(yArray) + ((Array.max(yArray) - Array.min(yArray)) / 2);
      {% endif %}

      return ort;
    }


    /**
     * Übernimmt Adresse aus Koordinaten eines Layers
     *
     * @param type - Typ
     * @param {layer} layer - Layer
     */
    function setAddressOrStreet(type, layer) {
      let json = layer.toGeoJSON();
      let ort = getCenter(json);
      let url = '{% url "datenmanagement:reversesearch" %}';
      fetch(url + '?search_class=address&x=' + ort[0] + '&y=' + ort[1], {
        method: 'GET'
      })
      .then(response => response.json())
      .then(data => {
        if (ort[0] != 0 && ort[1] != 0) {
          adoptResult(data, type)
        }
      })
      .catch(error => console.log(error))
    }


    /**
     *
     *
     *  @param {JSON} json -
     *  @param {string} type -
     */
    function adoptResult(json, type) {
      let erfolg = false;
      if (type === 'Straße') {
        jQuery.each(json.features, function(index, item) {
          if (item.properties.objektgruppe === 'Straße') {
            let text = item.properties._title_.substring(item.properties._title_.lastIndexOf(', ') + 2);
            if (item.properties.gemeindeteil_abkuerzung)
              text += ' (' + item.properties.gemeindeteil_abkuerzung + ')';
            $('#id_strasse').val(text);
            $('#id_strasse_uuid').val(item.properties.uuid);
            erfolg = true;
            return false;
          }
        });
        if (erfolg === false)
          modalToggler($('#maptostreet-error-modal'));
      } else if (type === 'Adresse') {
        jQuery.each(json.features, function(index, item) {
          if (item.properties.objektgruppe === 'Adresse') {
            let text = item.properties._title_.substring(item.properties._title_.lastIndexOf(', ') + 2);
            if (item.properties.gemeindeteil_abkuerzung)
              text += ' (' + item.properties.gemeindeteil_abkuerzung + ')';
            $('#id_adresse').val(text);
            $('#id_adresse_uuid').val(item.properties.uuid);
            erfolg = true;
            return false;
          }
        });
        if (erfolg === false)
          modalToggler($('#maptoaddress-error-modal'));
      }
    }


    /**
     * Anzeigen der Ergebnisse der Adresssuche
     *
     * @param json - Ergebnisse als Json
     */
    function showResults(json) {
      results.children().remove();  // alte Ergebnisse entfernen

      // JSON durchgehen und je Feature ein Resultat bauen
      jQuery.each(json.features, function(index, item) {
        // falls Feature nicht historisch ist:
        if (!item.properties.historisch) {
          let titel = '';
          if (item.properties._title_.indexOf(', ') != -1)
            titel = item.properties._title_.substring(item.properties._title_.lastIndexOf(', ') + 2);
          else
            titel = item.properties._title_;
          // falls Datenmodell Adressenbezug vorsieht:
          {% if address_type %}
            // nur Objektgruppen berücksichtigen, die mit dem Typ des Adressenbezugs übereinstimmen
            let substring = item.properties.objektgruppe;
            if (item.properties.objektgruppe.indexOf(' HRO') != -1)
              substring = item.properties.objektgruppe.substring(0, item.properties.objektgruppe.lastIndexOf(' HRO'));
            if (substring === '{{ address_type }}') {
              let result = '<div class="result-element" data-feature="' + index + '" data-uuid="' + item.properties.uuid + '"><strong>' + titel + '</strong>';
              if (item.properties.gemeindeteil_abkuerzung)
                result += ' <small>(' + item.properties.gemeindeteil_abkuerzung + ')</small>';
              result += '</div>';
              results.append(result);
            }
          // ansonsten: alle Objektgruppen anzeigen
          {% else %}
            let result = '<div class="result-element" data-feature="' + index + '" data-uuid="' + item.properties.uuid + '"><strong>' + titel + '</strong>';
            if (item.properties.gemeindeteil_abkuerzung)
              result += ' <small>(' + item.properties.gemeindeteil_abkuerzung + ')</small>';
            result += '<small class="text-black-50"><em>' + item.properties.objektgruppe.replace(/ HRO/, ''); + '</em></small></div>';
            results.append(result);
          {% endif %}
        }
      });

      // Resultate einblenden
      results.fadeIn();

      // bei Klick auf Resultat Karte auf dieses zoomen
      results.children().on('click', function() {
        $('#addressToMap').prop('disabled', false);
        {% if address_type %}
          var text = $(this).children('strong').text();
          if ($(this).children('small'))
            text += ' ' + $(this).children('small').text();
          {% if address_type == 'Adresse' %}
            $('#id_adresse').val(text);
            $('#id_adresse_uuid').val($(this).data('uuid'));
          {% elif address_type == 'Straße' %}
            $('#id_strasse').val(text);
            $('#id_strasse_uuid').val($(this).data('uuid'));
          {% endif %}
        {% else %}
          $('#id_address_search').val($(this).children('strong').text());
        {% endif %}
        FEATURE_GEOMETRY = json.features[$(this).data('feature')].geometry;
        if (FEATURE_GEOMETRY.type === 'Point') {
          window.currMap.fitBounds([
            [
              FEATURE_GEOMETRY.coordinates[1],
              FEATURE_GEOMETRY.coordinates[0]
            ],
            [
              FEATURE_GEOMETRY.coordinates[1],
              FEATURE_GEOMETRY.coordinates[0]
            ]
          ]);
        } else {
          window.currMap.fitBounds([
            [
              FEATURE_GEOMETRY.coordinates[0][0][1],
              FEATURE_GEOMETRY.coordinates[0][1][0]
            ],
            [
              FEATURE_GEOMETRY.coordinates[0][2][1],
              FEATURE_GEOMETRY.coordinates[0][0][0]
            ]
          ]);
        }
      });
    }


    function setAddressUuid() {
      /**
       * Adresse bzw. Straße auf Werte der entsprechenden Hidden-Input-Felder setzen
       */
      {% if address_type == 'Adresse' %}
        if ($.trim($('#id_adresse').val()).length)
          $('#id_adresse').val($('#id_adresse_uuid').val());
      {% elif address_type == 'Straße' %}
        if ($.trim($('#id_strasse').val()).length)
          $('#id_strasse').val($('#id_strasse_uuid').val());
      {% endif %}
      setCoordinates();
    }


    function modalToggler(modal) {
      modal.modal('toggle')
    }


    /**
     * @function
     * @name setCoordinates
     *
     * Koordinaten der gezeichneten Layer auf der Karten in Hidden-Inputfeld #id_geometry schreiben
     */
    function setCoordinates() {
      let jsonGeometrie;
      if (currMap.pm.getGeomanDrawLayers().length < 1){
        jsonGeometrie = {
          'type': '{{ geometry_type }}',
          {% if geometry_type == "Point" %}
            'coordinates': [0, 0],
          {% elif geometry_type == "Polygon" %}
            'coordinates': [[]],
          {% else %}
            'coordinates': [],
          {% endif %}
          };
        $('#id_geometrie').val(JSON.stringify(jsonGeometrie));
      } else {
        {% if geometry_type == 'MultiPolygon' or geometry_type == 'MultiPoint' or geometry_type == 'MultiLineString' %}
          let coords = [];
          let temp;

          currMap.pm.getGeomanDrawLayers().forEach(function (layer) {
            temp = layer.toGeoJSON().geometry;
            // Geoman malt mit Polygonen. Daher überprüfen ob Layer Polygon oder Multipolygon ist.
            if (temp.type.search('Multi') > -1) {
              for (let i = 0; i < temp.coordinates.length; i++) {
                coords.push(temp.coordinates[i]);
              }
            } else {
              coords.push(temp.coordinates);
            }
          });
          jsonGeometrie = {
            'type': '{{ geometry_type }}',
            'coordinates': coords,
          };
        {% else %}
          jsonGeometrie = currMap.pm.getGeomanDrawLayers()[0].toGeoJSON().geometry;
        {% endif %}
        $('#id_geometrie').val(JSON.stringify(jsonGeometrie));
      }
    }

    {% if gpx_input %}
      $('#id_gpx').change(function(e) {
        /**
         * @function
         * Bei Auswahl von Datei im GPX-Upload Feld, wird Label mit Dateinamen überschrieben und die ausgewählte GPX zum
         * Server geschickt. Als Response wird der Inhalt der GPX als GeoJson erwartet mit den zusätzlichen Attributen
         * 'Startzeitpunkt' und Endzeitpunkt. Diese Attribute werden beim Empfangen in die dafür vorgesehenen Input-Felder
         * geschrieben und die Geometrie auf der Karte gezeichnet.
         *
         * @param e
         */
        modalToggler($('#id_gpxLoading'));

        let file = e.target.files[0];
        let fileName = file.name;
        let formData = new FormData();
        formData.append('gpx', file);

        // Geoman-Layer von Karte entfernen (falls vorher schon eine Datei hochgeladen wurde)
        currMap.pm.getGeomanLayers().forEach((layer) => {
          if (layer.toGeoJSON().properties.datenthema !== 'Fallwildsuchen_Kontrollgebiete'){
            layer.remove();
          }
        });

        // Upload der GPX-Datei und Warten auf Response
        fetch(
          '{% url "datenmanagement:gpxtogeojson" %}', {
            method: 'POST',
            body: formData,
          }
        ).then(
          (response) => {
            return response.json();
          }
        ).then(
          (data) => {
            // Wenn data StatusCode enthält (Fehler bei der Kommunikation mit FME) => Ausgabe des Fehlers
            if (data.StatusCode){
              console.log('Fehler bei Kommunikation mit FME');
              console.log(data);
            } else {
              // Start- und Endzeitpunkt aus JSON auslesen und in Input-Felder schreiben
              $('#id_startzeitpunkt').val(data.features[0].properties.startzeitpunkt.slice(0, 19));
              $('#id_endzeitpunkt').val(data.features[0].properties.endzeitpunkt.slice(0, 19));
              // Layer erzeugen
              let track = new L.geoJSON(data, {
                color: 'red',
              });
              // Layer und alle Sublayer zu Geoman Draw Layer hinzufügen
              track._changeGeom = true;
              track.eachLayer((layer) => {
                layer._drawnByGeoman = true;
              });
              // Layer zur Karte hinzufügen
              track.addTo(currMap);
            }
            modalToggler($('#id_gpxLoading'));
          }
        ).catch(
          (error) => {
            $('#id_gpxLoading-title').text('Fehler bei Kommunikation mit Server');
            $('#id_gpxLoading-body').text(
              'Es ist ein Fehler bei der Kommunikation mit dem Server aufgetreten. ' +
              'Bitte versuchen Sie es erneut oder kontaktieren Sie einen Administrator.'
            );
            $('#id_gpxLoading-body').after(
              '<div class="modal-footer">' +
                '<button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>' +
              '</div>'
            );
            console.error(error);
          }
        );
      });
    {% endif %}

    {% if postcode_assigner %}
      $('#postcode_assigner').parent('span').click(function(e) {
        /**
         * @function
         * Beim Klick auf das Icon für die automatische Zuweisung
         * einer Postleitzahl wird der Server entsprechend angefragt.
         * Als Antwort des Servers wird ein GeoJSON erwartet
         * mit einem Attribut mit der Postleitzahl. Der Wert
         * dieses Attributes wird nach dem erfolgreichen Empfangen 
         * der Antwort des Servers in das dafür vorgesehene
         * Input-Feld geschrieben.
         *
         * @param e
         */

        let json = currMap.pm.getGeomanLayers()[0].toGeoJSON();
        let ort = getCenter(json);

        // Anfragen des Servers und Warten auf Antwort
        let params = {
          search_class: 'postcode_areas',
          x: ort[0],
          y: ort[1]
        };
        let query = Object.keys(params)
                    .map(k => encodeURIComponent(k) + '=' + encodeURIComponent(params[k]))
                    .join('&');
        let url = '{% url "datenmanagement:reversesearch" %}' + '?' + query;
        fetch(
          url
        ).then(
          (response) => {
            return response.json();
          }
        ).then(
          (data) => {
            if (data.features[0].properties.postleitzahl && typeof data.features[0].properties.postleitzahl == 'string')
              $('#postcode_assigner').parent().parent().next().find('input').val(data.features[0].properties.postleitzahl);
          }
        ).catch(
          (error) => {
            console.error(error);
            modalToggler($('#id_postcodeAssigning'));
          }
        );
      });
    {% endif %}


    {% if model_name == "Fallwildsuchen_Nachweise" %}
      /**
       * @function
       *
       * Laden des ausgewählten Kontrollgebietes im Rahmen einer Fallwildsuche
       */
      $('#id_kontrollgebiet').change(function() {
        let element = $('#id_kontrollgebiet option:selected')[0];
        let url = "{% url 'datenmanagement:'|add:'Fallwildsuchen_Kontrollgebiete'|add:'geometry' %}";
        currMap.pm.getGeomanLayers().forEach((layer) => {
          if (layer.toGeoJSON().properties.datenthema){
            layer.remove();
          }
        });
        fetch(
          String(url + '?pk=' + element.getAttribute('value'))
        ).then(
          (response) => {
            return response.json();
          }
        ).then(
          (data) => {
            let wkt = new Wkt.Wkt();
            let geom = data.geometry;
            wkt.read(geom.substring(geom.indexOf(';') + 1, geom.length));
            let geoJsonFeature = {
              type: 'Feature',
              geometry: null,
              properties: {
                'uuid': data.uuid,
                'datenthema': data.model_name,
              },
              crs: {
                type: 'name',
                properties: {
                  'name': 'urn:ogc:def:crs:EPSG::4326'
                }
              }
            };
            geoJsonFeature.geometry = wkt.toJson();
            new L.geoJSON(geoJsonFeature).addTo(currMap);
          }
        ).catch(
          (error) => {
            console.error(error);
          }
        );
      });
    {% endif %}
  </script>
{% endblock %}
