{% extends "_base/navbar.html" %}
{% load datenmanagement_tags %}
{% load guardian_tags %}
{% load leaflet_tags %}
{% load static %}

{% block title %}{{ model_verbose_name_plural }} | {% endblock %}

{% block style %}
  {{ block.super }}
  {% leaflet_css plugins="locatecontrol,markercluster" %}
  <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/datamap.css' %}" />
  {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/datamap-mobile.css' %}" />
  {% else %}
    <link rel="stylesheet" type="text/css" href="{% static 'datenmanagement/css/datamap-desktop.css' %}" />
  {% endif %}
{% endblock %}

{% block scripts %}
  {{ block.super }}
  {% leaflet_js plugins="locatecontrol,markercluster" %}
  <script type="text/javascript" src="{% static 'proj4/proj4.js' %}"></script>
  <script type="text/javascript" src="{% static 'proj4leaflet/proj4leaflet.js' %}"></script>
{% endblock %}

{% block content %}
  <h2>{{ model_verbose_name_plural }}</h2>
  <h4><small>{{ model_description }}</small></h4>
  <h4 class="mt-3">
    <em>
      {% if objects_count > 0 %}
        Karte aller Datensätze
      {% else %}
        Keine Datensätze vorhanden!
      {% endif %}
    </em>
  </h4>
  <div class="d-grid mb-3 gap-2 d-md-block">
    {% if user|user_has_model_add_permission:model_name_lower %}
      <a class="btn btn-primary" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'add' %}"><i class="fas fa-circle-plus"></i> neuen Datensatz anlegen</a>
    {% endif %}
    {% if objects_count > 0 %}
      <a class="btn btn-secondary" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'list' %}"><i class="fas fa-table"></i> Datensätze in Tabelle auflisten</a>
    {% endif %}
    <a class="btn btn-warning" role="button" href="{% url 'datenmanagement:'|add:model_name|add:'start' %}"><i class="fas fa-backward"></i> zurück</a>
  </div>
  {% if objects_count > 0 %}
	  <div id="map-side-container" class="mb-3">
      {% leaflet_map "map" callback="window.map_init_basic" %}
      {% if map_filters_enabled %}
        <div id="filter"{% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %} class="side"{% endif %}>
          <h5>Filter für Kartenobjekte</h5>
          <div id="filter-alert" class="alert alert-warning" role="alert">Filter wirken <strong>additiv</strong> (wie „UND“)</div>
          {% if map_deadlinefilter_fields %}
            <div id="filter-deadline">
              <div class="d-grid mt-2 mb-3">
                <label for="filter-input-deadline" class="form-label">Stichtag</label>
                <div class="input-group">
                  <input id="filter-input-deadline" type="date" name="deadline" class="form-control filter-input datetime-input" data-type="date" data-nullable data-intervalside="both">
                  <button class="input-reset btn btn-outline-secondary">
                    <i class="fas fa-trash" title="Filterfeld leeren"></i>
                  </button>
                </div>
              </div>
            </div>
          {% endif %}
          {% if map_rangefilter_fields and map_rangefilter_fields_labels %}
            <div id="filter-interval">
              {% for map_rangefilter_field in map_rangefilter_fields %}
                {% if not forloop.counter|divisibleby:2 %}
                  {% with naechster_index=forloop.counter0|add:1 %}
                  <div class="d-grid mt-2 mb-3">
                    <label for="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-label">{{ map_rangefilter_fields_labels|get_list_item_by_index:forloop.counter0 }}</label>
                    <div class="input-group">
                      {% if 'Date' in map_rangefilter_field|get_type_of_field:model_name %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime-local{% else %}date{% endif %}" name="{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input datetime-input" data-type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime{% else %}date{% endif %}" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="left" {% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}step="1"{% endif %}>
                        <button class="input-reset btn btn-outline-secondary">
                          <i class="fas fa-trash" title="Filterfeld leeren"></i>
                        </button>
                      {% else %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" type="text" name="{{ map_rangefilter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input" data-type="text" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="left">
                      {% endif %}
                    </div>
                  </div>
                  <div class="d-grid mt-2 mb-3">
                    <label for="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" class="form-label">{{ map_rangefilter_fields_labels|get_list_item_by_index:naechster_index }}</label>
                    <div class="input-group">
                      {% if 'Date' in map_rangefilter_field|get_type_of_field:model_name %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime-local{% else %}date{% endif %}" name="{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" class="form-control filter-input datetime-input" data-type="{% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime{% else %}date{% endif %}" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="right" {% if map_rangefilter_field|get_type_of_field:model_name == 'DateTimeField' %}step="1"{% endif %}>
                        <button class="input-reset btn btn-outline-secondary">
                          <i class="fas fa-trash" title="Filterfeld leeren"></i>
                        </button>
                      {% else %}
                        <input id="filter-input-{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" type="text" name="{{ map_rangefilter_fields|get_list_item_by_index:naechster_index }}" class="form-control filter-input" data-type="text" {% if map_rangefilter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="right">
                      {% endif %}
                    </div>
                  </div>
                  {% endwith %}
                {% endif %}
              {% endfor %}
            </div>
          {% endif %}
          {% if map_filter_fields and map_filter_fields_labels %}
            <div id="filter-normal">
              {% for map_filter_field in map_filter_fields %}
                <div class="d-grid mt-2 mb-3">
                  <label for="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-label{% if map_filter_field|get_type_of_field:model_name == 'ChoiceArrayField' %} filter-checkbox-label{% endif %}">{{ map_filter_fields_labels|get_list_item_by_index:forloop.counter0 }}</label>
                  {% if 'Date' in map_filter_field|get_type_of_field:model_name %}
                    <div class="input-group">
                      <input id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" type="{% if map_filter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime-local{% else %}date{% endif %}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input datetime-input" data-type="{% if map_filter_field|get_type_of_field:model_name == 'DateTimeField' %}datetime{% else %}date{% endif %}" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both" {% if map_filter_field|get_type_of_field:model_name == 'DateTimeField' %}step="1"{% endif %}>
                      <button class="input-reset btn btn-outline-secondary">
                        <i class="fas fa-trash" title="Filterfeld leeren"></i>
                      </button>
                    </div>
                  {% elif map_filter_field|get_type_of_field:model_name == 'BooleanField' %}
                    {% if map_filter_boolean_fields_as_checkbox %}
                      <div class="filter-input">
                        <input id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" type="checkbox" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-check-input" data-type="boolean" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both">
                      </div>
                    {% else %}
                      <div class="input-group">
                        <select id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-select filter-input" data-type="list" data-nullable data-boolean data-intervalside="both">
                          <option value="True">ja</option>
                          <option value="False">nein</option>
                        </select>
                        <button class="input-reset btn btn-outline-secondary">
                          <i class="fas fa-trash" title="Filterfeld leeren"></i>
                        </button>
                      </div>
                    {% endif %}
                  {% elif map_filter_fields_as_list and map_filter_field in map_filter_fields_as_list %}
                    <div class="input-group">
                      <select id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-select filter-input" data-type="list" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both"></select>
                      <button class="input-reset btn btn-outline-secondary">
                        <i class="fas fa-trash" title="Filterfeld leeren"></i>
                      </button>
                    </div>
                  {% elif map_filter_field|get_type_of_field:model_name == 'ChoiceArrayField' %}
                    <div class="d-grid gap-2 d-md-block">
                      Listeneinträge
                      <select id="filtertype-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-select filtertype">
                        <option value="additive">additiv (wie „UND“)</option>
                        <option value="exclusive">exklusiv (wie „ODER“)</option>
                      </select>
                      filtern
                    </div>
                    <fieldset id="filter-checkbox-fieldset-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control mt-2 filter-checkbox-fieldset" data-type="checkbox-set" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both"></fieldset>
                  {% else %}
                    <div class="input-group">
                      <input id="filter-input-{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" type="text" name="{{ map_filter_fields|get_list_item_by_index:forloop.counter0 }}" class="form-control filter-input" data-type="text" {% if map_filter_field|is_field_nullable:model_name %}data-nullable{% endif %} data-intervalside="both">
                      <button class="input-reset btn btn-outline-secondary">
                        <i class="fas fa-trash" title="Filterfeld leeren"></i>
                      </button>
                    </div>
                  {% endif %}
                </div>
              {% endfor %}
            </div>
          {% endif %}
          <div id="filter-buttons" class="d-grid mt-4 gap-2 d-md-block">
            <button id="filter-apply" class="btn btn-success" type="submit"><i class="fas fa-filter"></i> Filter anwenden</button>
            <button id="filter-reset" class="btn btn-warning" type="submit"><i class="fas fa-filter-circle-xmark"></i> Filter zurücksetzen</button>
          </div>
        </div>
      {% endif %}
      <div {% if map_filters_enabled %}id="map-control"{% endif %}{% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %} class="side"{% endif %}>
        <h5>Kartenausschnitt</h5>
        <div class="d-grid mt-2 gap-2 d-md-block">
          <button id="map-extent-filter" class="btn btn-success" type="submit"><i class="fas fa-map-location"></i> {% if map_filters_enabled %}aktuelle Filtermenge{% else %}alle Objekte{% endif %}</button>
          <button id="map-extent-initial" class="btn btn-warning" type="submit"><i class="fas fa-map"></i> gesamt</button>
        </div>
      </div>
      <div id="address-search"{% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %} class="side"{% endif %}>
        <h5>Adressensuche</h5>
        <div class="form-floating">
          <input id="searchtext" type="text" class="form-control" name="searchtext" autocapitalize="off" autocomplete="off" placeholder="Adresse, Straße oder Gemeindeteil eingeben…">
          <label for="searchtext">Adresse, Straße oder Gemeindeteil eingeben…</label>
        </div>
        <div id="results-container" class="results"></div>
      </div>
    </div>
    {% if heavy_load_limit %}
      <div id="id_mapDataLoading" class="modal fade" tabindex="-1" aria-labelledby="id_mapDataLoading-label" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header" id="id_mapDataLoading-header">
              <h5 class="modal-title" id="id_mapDataLoading-title">Laden der Kartendaten</h5>
            </div>
            <div class="modal-body" id="id_mapDataLoading-body">
              Die Kartendaten werden (nach-)geladen. Dies kann einen Moment dauern, da es sich insgesamt um eine sehr große Datenmenge handelt.
              <div class="text-center">
                <div class="spinner-border m-4 text-primary" role="status">
                  <span class="sr-only">laden…</span>
                </div>
                <div class="m-4">
                  <span id="id_mapDataLoading-count"></span> von <span id="id_mapDataLoading-border"></span> Datensätzen geladen
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    {% endif %}
    <script type="text/javascript">
      /**
       * behandelt als Callback-Funktion die übergebene Karte
       *
       * @param {Object} map - Karte
       */
      function map_init_basic(map) {
        // Rendering der Features auf der Karte etwas beschleunigen
        map.preferCanvas = true;

        // Karte auch in anderen JavaScript-Funktionen verfügbar machen
        window.currMap = map;

        // Standard-Zoom-Kontrollelemente entfernen und durch solche mit eigenen Tooltips ersetzen
        map.zoomControl.remove();
        L.control.zoom({
          zoomInTitle:'hineinzoomen',
          zoomOutTitle:'herauszoomen'
        }).addTo(map);

        // Konstanten definieren
        const wmsFormat = 'image/png';
        const maxZoom = 19;

        // ORKa.MV definieren
        const orkamv =  L.tileLayer('https://www.orka-mv.de/geodienste/orkamv/tiles/1.0.0/orkamv/GLOBAL_WEBMERCATOR/{z}/{x}/{y}.png', {
          maxZoom: maxZoom,
          attribution: 'Kartenbild © Hanse- und Universitätsstadt Rostock (<a href="https://creativecommons.org/licenses/by/4.0/deed.de" target="_blank">CC BY 4.0</a>)<br>Kartendaten © <a href="https://www.openstreetmap.org/" target="_blank">OpenStreetMap</a> (<a href="https://opendatacommons.org/licenses/odbl/" target="_blank">ODbL</a>) und LkKfS-MV'
        });

        // ORKa.MV standardmäßig zur Karte hinzufügen
        map.addLayer(orkamv);

        // OpenStreetMap definieren
        const osm =  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: maxZoom,
          attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap-Mitwirkende</a>'
        });

        // basemap.de definieren
        const basemapde = L.tileLayer.wms('https://sgx.geodatenzentrum.de/wms_basemapde', {
          layers: 'de_basemapde_web_raster_farbe',
          format: wmsFormat,
          maxZoom: maxZoom,
          attribution: '© GeoBasis-DE/BKG'
        });

        // Liegenschaftskarte definieren
        const liegenschaftskarte = L.tileLayer.wms('{% url "datenmanagement:owsproxy" %}' + '/liegenschaftskarte/wms', {
          layers: 'hro.liegenschaftskarte',
          format: wmsFormat,
          maxZoom: maxZoom,
          attribution: '© Hanse- und Universitätsstadt Rostock (MLV intern)'
        });

        // Luftbild definieren
        const luftbild =  L.tileLayer('{% url "datenmanagement:owsproxy" %}' + '/luftbild_mv-20/tiles/1.0.0/hro.luftbild_mv-20.luftbild_mv-20/GLOBAL_WEBMERCATOR/{z}/{x}/{y}.png', {
          maxZoom: maxZoom,
          attribution: '© GeoBasis-DE/M-V'
        });

        // Kilometerquadrate ETRS89/UTM-33N definieren
        const kilometerquadrate = L.tileLayer.wms('https://geo.sv.rostock.de/geodienste/koordinatensysteme/wms', {
          layers: 'hro.koordinatensysteme.kilometerquadrate_utm',
          format: wmsFormat,
          maxZoom: maxZoom,
          transparent: true
        });

        // definierte Karten als Hintergrundkarten zusammenfassen
        const baseMaps = {
          'basemap.de': basemapde,
          'Liegenschaftskarte': liegenschaftskarte,
          'Luftbild': luftbild,
          'OpenStreetMap': osm,
          'ORKa.MV': orkamv
        };

        // definierte Karten als Overlay-Karten zusammenfassen
        const overlayMaps = {
          'Kilometerquadrate ETRS89/UTM-33N': kilometerquadrate
        };

        // Umschalter für Hintergrundkarten zur Karte hinzufügen
        L.control.layers(baseMaps,overlayMaps).addTo(map);

        {% if request.user_agent.is_mobile or request.user_agent.is_tablet %}
          // bei mobilen Geräten: Standortbestimmung hinzufügen
          L.control.locate({
            drawCircle: false,
            drawMarker: false,
            flyTo: true,
            locateOptions: {
              enableHighAccuracy: true
            },
            setView: 'untilPan',
            strings: {
              title: 'Standortbestimmung'
            }
          }).addTo(map);
        {% endif %}

        // EPSG:25833 definieren
        proj4.defs([
          [
            'EPSG:25833',
            '+proj=utm +zone=33 +ellps=WGS84 +towgs84=0,0,0,0,0,0,1 +units=m +no_defs'
          ],
        ]);

        /**
         * definiert Aktionen und Eigenschaften für jeden Feature-Layer auf der Karte
         *
         * @param {Object} feature - Feature
         * @param {Object} layer - Feature-Layer
         */
        function onEachFeature(feature, layer) {
          // falls Nutzer die notwendige Berechtigung hat...
          if (feature.properties.link) {
            layer.on('click', function () {
              // jedem Feature einen Link auf dessen Bearbeitungsseite mitgeben
              window.open(feature.properties.link, '_blank').focus();
            });
          }
          // falls Feature inaktiv ist...
          if (typeof feature.properties.inaktiv !== 'undefined' && feature.properties.inaktiv) {
            // Feature entsprechend darstellen
            layer.setStyle({
              color: '#999',
              fillColor: '#999'
            });
          }
          // falls Feature-Highlighting vorgesehen ist...
          {% if highlight_flag %}
            if (typeof feature.properties.highlight !== 'undefined' && feature.properties.highlight) {
              // Feature highlighten
              layer.setStyle({
                color: '#ff0000',
                fillColor: '#ff0000'
              });
            }
          {% endif %}
          // Feature ausblenden, falls es von initialer Feature-Ausblendung betroffen ist
          {% if map_filter_hide_initial %}
            if (typeof feature.properties.hide_initial !== 'undefined' && feature.properties.hide_initial)
              layer.setStyle({
                fill: false,
                stroke: false,
                opacity: 0
              });
          {% endif %}
          // falls Geometrie nicht punkthaft ist...
          {% if geometry_type != 'Point' %}
            layer.bindTooltip(feature.properties.tooltip);
          {% endif %}
        }

        // falls große Datenmenge zu erwarten ist...
        {% if heavy_load_limit %}
          // Konstanten und Variablen für die Anzahl der (bereits geholten) GeoJSON-Feature definieren
          const border = {{ objects_count }};
          const limit = {{ heavy_load_limit }};
          let promises = [];
          let count = 0;
          // Zähler im Bootstrap-Modal setzen, das während des Ladevorgangs der GeoJSON-FeatureCollection für die Karte eingeblendet wird
          $('#id_mapDataLoading-count').text(count);
          $('#id_mapDataLoading-border').text(border);
        {% endif %}

        /**
         * schaltet die Sichtbarkeit des übergebenen Bootstrap-Modals um
         *
         * @param {Object} modal - Bootstrap-Modal
         */
        function modalToggler(modal) {
          modal.modal('toggle')
        }

        /**
         * holt die GeoJSON-FeatureCollection für die Karte
         *
         * @param {boolean} heavyLoad - große Datenmenge zu erwarten?
         * @param {number} [limit=0] - Limit für aktuellen Ladeschritt
         * @param {number} [offset=0] - Offset für aktuellen Ladeschritt (= Vielfaches des Limits für aktuellen Ladeschritt)
         */
        async function fetchGeoJsonFeatureCollection(heavyLoad = false, limit = 0, offset = 0) {
          try {
            let url = '{% url 'datenmanagement:'|add:model_name|add:'mapdata' %}';
            if (heavyLoad) {
              url += '?limit=' + limit + '&offset=' + offset;
            }
            modalToggler($('#id_mapDataLoading'));
            const response = await fetch(url, {
              method: 'GET'
            });
            const data = await response.json();
            if (heavyLoad) {
              count += data.features.length;
              $('#id_mapDataLoading-count').text(count);
              if (count === border) {
                modalToggler($('#id_mapDataLoading'));
              }
            } else
              modalToggler($('#id_mapDataLoading'));
            return data;
          } catch (error) {
            console.error(error);
          }
        }

        // falls Geometrie punkthaft ist...
        {% if geometry_type == 'Point' %}
          // Cluster aktivieren
          let markers = L.markerClusterGroup();
          // neuen GeoJSON-Layer definieren, mit GeoJSON-FeatureCollection für die Karte befüllen und zur Karte hinzufügen
          // falls große Datenmenge zu erwarten ist...
          {% if heavy_load_limit %}
            // GeoJSON-FeatureCollection für die Karte in mehreren Ladeschritten holen, die alle parallel ausgeführt werden
            for (let offset = 0; offset < border; offset += limit) {
              promises.push(fetchGeoJsonFeatureCollection(true, limit, offset));
            }
            Promise.all(promises)
            .then(data => {
              L.Proj.geoJson(data, {
                pointToLayer: function (feature, latlng) {
                  let marker = new L.circleMarker(latlng, {
                    radius: 5
                  });
                  marker.bindTooltip(feature.properties.tooltip);
                  return marker;
                },
                onEachFeature: onEachFeature
              }).addTo(markers);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          // ansonsten...
          {% else %}
            // GeoJSON-FeatureCollection für die Karte in einem Ladeschritt holen
            fetchGeoJsonFeatureCollection()
            .then(data => {
              L.Proj.geoJson(data, {
                pointToLayer: function (feature, latlng) {
                  let marker = new L.circleMarker(latlng, {
                    radius: 5
                  });
                  marker.bindTooltip(feature.properties.tooltip);
                  return marker;
                },
                onEachFeature: onEachFeature
              }).addTo(markers);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          {% endif %}
          markers.id = 'cluster';
          map.addLayer(markers);
        // ansonsten...
        {% else %}
          // neuen GeoJSON-Layer definieren, mit GeoJSON-FeatureCollection für die Karte befüllen und zur Karte hinzufügen
          // falls große Datenmenge zu erwarten ist...
          {% if heavy_load_limit %}
            // GeoJSON-FeatureCollection für die Karte in mehreren Ladeschritten holen, die alle parallel ausgeführt werden
            for (let offset = 0; offset < border; offset += limit) {
              promises.push(fetchGeoJsonFeatureCollection(true, limit, offset));
            }
            Promise.all(promises)
            .then(data => {
              L.Proj.geoJson(data, {
                onEachFeature: onEachFeature
              }).addTo(map);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          // ansonsten...
          {% else %}
            // GeoJSON-FeatureCollection für die Karte in einem Ladeschritt holen
            fetchGeoJsonFeatureCollection()
            .then(data => {
              L.Proj.geoJson(data, {
                onEachFeature: onEachFeature
              }).addTo(map);
            })
            .catch(
              (error) => {
                console.error(error);
              }
            );
          {% endif %}
        {% endif %}

        // gemeinsame Bounding-Box aller Objekte auch in anderen JavaScript-Funktionen verfügbar machen
        window.objectsExtent = map.getBounds();

        // globale Variable für gelöschte Cluster-Features auch in anderen JavaScript-Funktionen verfügbar machen
        window.removedLayers = [];
      }

      // Adressensuche und Filter
      $(document).ready(function() {
        // Variable für Bounding-Box der aktuellen Filtermenge anlegen
        let currentFilterExtent = [];

        // Variable für minimale Werte von entsprechenden Intervallfilterfeldern anlegen
        let intervalFilterMin = [];

        // Variable für maximale Werte von entsprechenden Intervallfilterfeldern anlegen
        let intervalFilterMax = [];

        // Variablen für Wertelisten für entsprechende Filterfelder anlegen, die als Auswahlfeld dargestellt werden sollen
        let listFilterLists = [];
        let listFilterListsValues = {{ list_filter_lists|safe }};

        // Variablen für Wertelisten für entsprechende Filterfelder anlegen, die als Checkboxen-Set dargestellt werden sollen
        let checkboxFilterLists = [];
        let checkboxFilterListsValues = {{ checkbox_filter_lists|safe }};

        // Adressensuche initialisieren
        let results = $('div.results');
        let searchField = $('#searchtext');

        // bei Klick auf Stelle außerhalb der Adressensuche die Resultate der Adressensuche leeren
        results.click(function(event) {
          $('html').one('click',function() {
            results.children().remove();
            results.fadeOut();
          });
          event.stopPropagation();
        });

        // bei Eingabe in entsprechendes Eingabefeld Adressensuche durchführen
        searchField.keyup(function() {
          if ($(this).val().length >= 3) {
            let searchText = searchField.val();
            let url = '{% url "datenmanagement:addresssearch" %}';
            fetch(url + '?query=' + searchText, {
              method: 'GET'
            })
            .then(response => response.json())
            .then(data => showResults(data))
            .catch(error => console.log(error))
          } else {
            results.children().remove();
            results.fadeOut();
          }
        });

        // bei Klick in Eingabefeld für Adressensuche dieses und die Resultate der Adressensuche leeren
        $('#searchtext').on('click', function() {
          $(this).val('');
          $('#results-container').hide();
        });

        // Filter initialisieren

        // über alle Filterfelder (außer Boolean- und Checkbox-Filterfelder) gehen...
        $('.filter-input').each(function() {
          // Feld als Objekt mit Name und Typ erstellen
          let filterField = {};
          filterField.name = $(this).attr('name');
          filterField.type = $(this).data('type');
          // falls es sich um ein Intervallfilterfeld handelt...
          if ($(this).data('intervalside') === 'left' || $(this).data('intervalside') === 'right') {
            // falls es sich um ein "linkes" Intervallfilterfeld (also für niedrigere/kleinere/frühere Werte) handelt...
            if ($(this).data('intervalside') === 'left') {
              // Feldobjekt zur Variable für minimale Werte von entsprechenden Intervallfilterfeldern hinzufügen
              filterField.value = '{{ interval_filter_min }}';
              intervalFilterMin.push(filterField);
            // falls es sich um ein "rechtes" Intervallfilterfeld (also für höhere/größere/spätere Werte) handelt...
            } else if ($(this).data('intervalside') === 'right') {
              // Feldobjekt zur Variable für maximale Werte von entsprechenden Intervallfilterfeldern hinzufügen
              filterField.value = '{{ interval_filter_max }}';
              intervalFilterMax.push(filterField);
            }
          // falls es sich um ein Listenfeld handelt...
          } else if ($(this).data('type') === 'list' && $(this).attr('name') in listFilterListsValues) {
            // Feldobjekt zur Variable für Wertelisten für entsprechende Filterfelder hinzufügen, die als Auswahlfeld dargestellt werden sollen
            filterField.value = listFilterListsValues[filterField.name];
            listFilterLists.push(filterField);
          }
        });

        // über alle Boolean-Filterfelder gehen...
        $('.filter-input input[type="checkbox"]').each(function() {
          // Feld als Objekt mit Name und Typ erstellen
          let filterField = {};
          filterField.name = $(this).attr('name');
          filterField.type = $(this).data('type');
          if ($(this).is(':checked')) {
            filterField.value = 'True';
          } else {
            filterField.value = 'False';
          }
          if ($(this).attr('name') in listFilterListsValues)
            listFilterLists.push(filterField);
        });

        // über alle Checkbox-Filterfelder gehen...
        $('.filter-checkbox-fieldset').each(function() {
          // Feld als Objekt mit Name, Typ und Wert erstellen
          let filterField = {};
          filterField.name = $(this).attr('name');
          filterField.type = $(this).data('type');
          filterField.value = checkboxFilterListsValues[filterField.name];
          // Feldobjekt zur Variable für Wertelisten für entsprechende Filterfelder hinzufügen, die als Checkboxen-Set dargestellt werden sollen
          checkboxFilterLists.push(filterField);
        });

        // Date-/Time-/Date-Time-Picker für jedes relevante Filterfeld initialisieren
        $('.datetime-input').each(function() {
          // Variable für initiales Datum bzw. initiales Datum mit Zeit
          let initialDateTime = '';

          // falls Filterfeld in Variable für minimale Werte von entsprechenden Intervallfilterfeldern auftritt: Variable für initiales Datum bzw. initiales Datum mit Zeit auf dortigen Wert setzen
          for (let i = 0; i < intervalFilterMin.length; i++) {
            if (intervalFilterMin[i].name === $(this).attr('name')) {
              initialDateTime = intervalFilterMin[i].value;
              break;
            }
          }

          // falls Filterfeld in Variable für maximale Werte von entsprechenden Intervallfilterfeldern auftritt: Variable für initiales Datum bzw. initiales Datum mit Zeit auf dortigen Wert setzen
          for (let j = 0; j < intervalFilterMax.length; j++) {
            if (intervalFilterMax[j].name === $(this).attr('name')) {
              initialDateTime = intervalFilterMax[j].value;
              break;
            }
          }

          // falls Variable für initiales Datum bzw. initiales Datum mit Zeit gefüllt ist...
          if (initialDateTime !== '') {
            // initiales Datum bzw. initiales Datum mit Zeit auf entsprechenden Wert setzen
            $(this).val(initialDateTime);
            // data-Attribut hinzufügen mit initialem Datum bzw. initialem Datum mit Zeit (benötigt beim Zurücksetzen der Filter)
            $(this).attr('data-initial', initialDateTime);
          }
        });

        // Listenfelder initialisieren
        $("select[data-type='list']").each(function() {
          // Variable für Wertelisten für entsprechende Filterfelder durchgehen, die als Auswahlfeld dargestellt werden sollen...
          for (let i = 0; i < listFilterLists.length; i++) {
            if (listFilterLists[i].name === $(this).attr('name')) {
              if (typeof $(this).data('boolean') == 'undefined') {
                for (let j = 0; j < listFilterLists[i].value.length; j++) {
                  // Werteliste als Optionen im Listenfeld abbilden
                  $(this).append($('<option>', {
                    value: listFilterLists[i].value[j],
                    text: listFilterLists[i].value[j]
                  }));
                }
              }
              break;
            }
          }
          // zum Abschluss sciherstellen, dass Listenfeld initial auf leerer Option steht
          $(this).val('');
        });

        // Checkboxen-Sets initialisieren
        $('.filter-checkbox-fieldset').each(function() {
          // Variable für Wertelisten für entsprechende Filterfelder durchgehen, die als Checkboxen-Set dargestellt werden sollen...
          for (let i = 0; i < checkboxFilterLists.length; i++) {
            if (checkboxFilterLists[i].name === $(this).attr('name')) {
              for (let j = 0; j < checkboxFilterLists[i].value.length; j++) {
                // Werteliste als Checkboxen im Set abbilden
                let $label = $('<label>').attr('for', 'checkbox-' + i + '-' + j);
                $label.append($('<input>', {
                  id: 'checkbox-' + i + '-' + j,
                  class: 'form-check-input',
                  type: 'checkbox',
                  value: checkboxFilterLists[i].value[j]
                }));
                $label.append(checkboxFilterLists[i].value[j]);
                $(this).append($label);
              }
              break;
            }
          }
        });

        // bei Klick auf entsprechenden Button alle Filter anwenden
        $('#filter-apply').on('click', function() {
          // Hinweise auf additive Wirkung der Filter anzeigen
          $('#filter-alert').show();

          // Variable für Bounding-Box der aktuellen Filtermenge leeren
          currentFilterExtent = [];

          // Liste für Filterobjekte
          let filterAttributesList = [];

          // über alle Filter (außer Boolean-Filter und Checkboxen-Sets) gehen...
          $('.filter-input').each(function() {
            if ($(this).val()) {
              // Filter als Objekt mit Name, Typ, "Intervallseite" und Wert erstellen
              let filterAttribute = {};
              filterAttribute.name = $(this).attr('name');
              filterAttribute.type = $(this).data('type');
              filterAttribute.intervalside = $(this).data('intervalside');
              filterAttribute.value = $(this).val();
              // Filterobjekt zur Liste für Filterobjekte hinzufügen
              filterAttributesList.push(filterAttribute);
            }
          });

          // über alle Boolean-Filter gehen...
          $('.filter-input input[type="checkbox"]').each(function() {
            // Filter als Objekt mit Name, Typ, "Intervallseite" und Wert erstellen
            let filterAttribute = {};
            filterAttribute.name = $(this).attr('name');
            filterAttribute.type = $(this).data('type');
            filterAttribute.intervalside = $(this).data('intervalside');
            if ($(this).is(':checked')) {
              filterAttribute.value = 'True';
            } else {
              filterAttribute.value = 'False';
            }
            // Filterobjekt zur Liste für Filterobjekte hinzufügen
            filterAttributesList.push(filterAttribute);
          });

          // über alle Checkboxen-Sets gehen...
          $('.filter-checkbox-fieldset').each(function() {
            // Filter als Objekt mit Name, Typ, "Intervallseite" und Wert (als Liste) erstellen
            let checkedObjectsAtAll = false;
            let filterAttribute = {};
            let name = $(this).attr('name');
            filterAttribute.name = name;
            filterAttribute.type = $(this).data('type');
            filterAttribute.filtertype = $('select[id^=filtertype-' + name + ']').children('option:selected').val();
            filterAttribute.intervalside = $(this).data('intervalside');
            filterAttribute.value = [];
            // Wertliste des Filterobjekts mit dem Wert jeder aktiven Checkbox befüllen
            $(this).find('input:checked').each(function() {
              checkedObjectsAtAll = true;
              filterAttribute.value.push($(this).val());
            });
            if (checkedObjectsAtAll)
              filterAttributesList.push(filterAttribute);
          });


          /**
           * filtert Layer (= Features) auf der Karte
           *
           * @param {Object} layer - Layer (= Feature)
           * @param {boolean} isSubLayer - Layer (= Feature) ist Bestandteil einer Layergruppe (= eines Clusters)?
           * @param {Object} [clusterLayer=layer] - Layergruppe (= Cluster), falls vorhanden; standardmäßig auf den Layer (= das Feature) gesetzt
           */
          function mapFilter(layer, isSubLayer, clusterLayer = layer) {
            let stillVisible = true;
            for (let i = 0; i < filterAttributesList.length; i++) {
              // bei Stichtagsfilter einen entsprechenden Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
              if (filterAttributesList[i].name === 'deadline') {
                // auf passende Formatierung achten, das es sich beim Filter um einen Datumsfilter handelt!
                if (!(new Date(filterAttributesList[i].value) > new Date(layer.feature.properties['deadline_0'])) || !(new Date(layer.feature.properties['deadline_1']) > new Date(filterAttributesList[i].value)))
                  stillVisible = false;
              // bei "linkem" Intervallfilter (also für niedrigere/kleinere/frühere Werte) einen "kleiner"-Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
              } else if (filterAttributesList[i].intervalside === 'left') {
                if (filterAttributesList[i].type === 'date') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
                  if (new Date(filterAttributesList[i].value) > new Date(layer.feature.properties[filterAttributesList[i].name]))
                    stillVisible = false;
                } else if (filterAttributesList[i].type === 'datetime') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
                  if (new Date(filterAttributesList[i].value).valueOf() > new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf())
                    stillVisible = false;
                } else {
                  if (filterAttributesList[i].value > layer.feature.properties[filterAttributesList[i].name])
                    stillVisible = false;
                }
              // bei "rechtem" Intervallfilter (also für höhere/größere/spätere Werte) einen "größer"-Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
              } else if (filterAttributesList[i].intervalside === 'right') {
                if (filterAttributesList[i].type === 'date') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
                  if (new Date(layer.feature.properties[filterAttributesList[i].name]) > new Date(filterAttributesList[i].value))
                    stillVisible = false;
                } else if (filterAttributesList[i].type === 'datetime') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
                  if (new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf() > new Date(filterAttributesList[i].value).valueOf())
                    stillVisible = false;
                } else {
                  if (layer.feature.properties[filterAttributesList[i].name] > filterAttributesList[i].value) 
                    stillVisible = false;
                }
              // bei Checkboxen-Sets String-Vergleich mit allen aktivierten Checkboxen durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken, falls einzelne Checkboxen additiv wirken sollen
              } else if (filterAttributesList[i].type === 'checkbox-set' && filterAttributesList[i].value.length > 0) {
                if (filterAttributesList[i].filtertype === 'additive') {
                  for (let j = 0; j < filterAttributesList[i].value.length; j++) {
                    if (layer.feature.properties[filterAttributesList[i].name].toLowerCase().indexOf(filterAttributesList[i].value[j].toLowerCase()) === -1)
                      stillVisible = false;
                  }
                } else {
                  stillVisible = false;
                  for (let k = 0; k < filterAttributesList[i].value.length; k++) {
                    if (layer.feature.properties[filterAttributesList[i].name].toLowerCase().indexOf(filterAttributesList[i].value[k].toLowerCase()) !== -1) {
                      stillVisible = true;
                      break;
                    }
                  }
                }
              // ansonsten einen Vergleich durchführen und Layer (= Feature) ggf. zur Ausblendung vormerken
              } else if (filterAttributesList[i].type !== 'checkbox-set') {
                if (filterAttributesList[i].type === 'date') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Datumsfilter handelt!
                  if (new Date(filterAttributesList[i].value).valueOf() !== new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf())
                    stillVisible = false;
                } else if (filterAttributesList[i].type === 'datetime') {
                  // auf passende Formatierung achten, wenn es sich beim Filter um einen Filter mit Datum und Zeit handelt!
                  if (new Date(filterAttributesList[i].value).valueOf() !== new Date(layer.feature.properties[filterAttributesList[i].name]).valueOf())
                    stillVisible = false;
                } else if (filterAttributesList[i].type === 'list') {
                  if (layer.feature.properties[filterAttributesList[i].name].toLowerCase() !== filterAttributesList[i].value.toLowerCase())
                    stillVisible = false;
                } else {
                  if (layer.feature.properties[filterAttributesList[i].name].toLowerCase().indexOf(filterAttributesList[i].value.toLowerCase()) === -1)
                    stillVisible = false;
                }                    
              }
            }
            // falls Layer (= Feature) nicht zur Ausblendung vorgemerkt ist, also weiterhin sichtbar sein soll:
            if (stillVisible) {
              // Variable für Bounding-Box der aktuellen Filtermenge aktualisieren
              let north = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lat : layer.getBounds().getNorth());
              let east = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lng : layer.getBounds().getEast());
              let south = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lat : layer.getBounds().getSouth());
              let west = ((layer.feature.geometry.type === 'Point') ? layer.getLatLng().lng : layer.getBounds().getWest());
              if (currentFilterExtent.length === 0) {
                currentFilterExtent[0] = [];
                currentFilterExtent[0][0] = north;
                currentFilterExtent[0][1] = east;
                currentFilterExtent[1] = [];
                currentFilterExtent[1][0] = south;
                currentFilterExtent[1][1] = west;
              } else {
                if (currentFilterExtent[0][0] > north)
                  currentFilterExtent[0][0] = north;
                if (currentFilterExtent[0][1] > east)
                  currentFilterExtent[0][1] = east;
                if (currentFilterExtent[1][0] < south)
                  currentFilterExtent[1][0] = south;
                if (currentFilterExtent[1][1] < west)
                  currentFilterExtent[1][1] = west;
              }
              // Layer (= Feature) einblenden, falls es von initialer Feature-Ausblendung betroffen ist
              {% if map_filter_hide_initial %}
                if (typeof layer.feature.properties.hide_initial !== 'undefined' && layer.feature.properties.hide_initial) {
                  layer.setStyle({
                    color: '#3388ff',
                    fill: true,
                    fillColor: '#3388ff',
                    stroke: true,
                    opacity: 1
                  });
                }
              {% endif %}
            // ansonsten:
            } else {
              // Layer (= Feature) tatsächlich ausblenden
              if (isSubLayer) {
                window.removedLayers.push(layer);
                clusterLayer.removeLayer(layer);
              } else
                layer.getElement().style.display = 'none';
            }
          }


          // über alle Filterobjekte gehen...
          if (filterAttributesList.length > 0) {
            showAllMapFeatures();
            window.currMap.eachLayer(function(layer) {
              if (layer.feature) {
                mapFilter(layer, false);
              } else if (layer.id === 'cluster') {
                let clusterLayer = layer;
                layer.eachLayer(function(subLayer) {
                  mapFilter(subLayer, true, clusterLayer);
                });
                layer.refreshClusters();
              }
            });
          } else {
            showAllMapFeatures();
          }
        });

        // bei Klick auf entsprechenden Button alle Filter sowie Bounding-Box der aktuellen Filtermenge zurücksetzen
        $('#filter-reset').on('click', function() {
          // Hinweise auf additive Wirkung der Filter (wieder) verbergen
          $('#filter-alert').hide();

          $('.filter-input').each(function() {
            // falls initialer Wert vorhanden...
            if ($(this).data('initial'))
              // Filter auf initialen Wert setzen
              $(this).val($(this).data('initial'));
            // ansonsten Filter auf leeren Wert setzen
            else
              $(this).val('');
          });

          $('.filter-input input[type="checkbox"]').each(function() {
            // falls initialer Wert vorhanden...
            if ($(this).data('initial')) {
              // Filter auf initialen Wert setzen
              let initialValue = $(this).data('initial');
              if (initialValue.toLowerCase() === 'false') {
                $(this).prop('checked', false);
              } else {
                $(this).prop('checked', true);
              }
            }
            // ansonsten Filter auf leeren Wert setzen
            else {
              $(this).prop('checked', false);
            }
          });

          $('.filter-checkbox-fieldset').each(function() {
            $(this).find('input:checked').each(function() {
              $(this).prop('checked', false);
            });
          });
          
          $('.filtertype').each(function() {
            $(this)[0].selectedIndex = 0;
          });

          showAllMapFeatures();
          currentFilterExtent = [];
        });

        // bei Klick auf entsprechendes Kreuzchen Inhalt des betreffenden Filters leeren
        $('.input-reset').on('click', function() {
          $(this).prev().is('button') ? $(this).prev().prev().val('') : $(this).prev().val('');
        });

        // bei Klick auf Button zum Setzen des initialen Kartenausschnitts
        $('#map-extent-initial').on('click', function() {
          // initiales Zoomlevel aus Leaflet-Konfiguration aus settings.py auslesen
          let defaultZoom = String('{{ LEAFLET_CONFIG }}'.match(/DEFAULT_ZOOM(?:(?!, &#39).)*/));
          defaultZoom = defaultZoom.match(/ [0-9]+/).toString().trim();
          // initiales Kartenzentrum aus Leaflet-Konfiguration aus settings.py auslesen
          let defaultCenter = String('{{ LEAFLET_CONFIG }}'.match(/DEFAULT_CENTER(?:(?!, &#39).)*/));
          let defaultCenterX = String(defaultCenter.match(/ [0-9]+\.[0-9]+/)).trim();
          let defaultCenterY = String(defaultCenter.match(/[0-9]+\.[0-9]+/)).trim();
          // Kartenausschnitt mittels Kartenzentrum und Zoom-Level setzen
          setMapExtentByXYAndZoomLevel(defaultCenterX, defaultCenterY, defaultZoom);
        });

        // bei Klick auf Button zum Setzen des Kartenausschnitts auf Bounding-Box der aktuellen Filtermenge (bzw. auf Bounding-Box aller Objekte, falls kein Filter aktiv)
        $('#map-extent-filter').on('click', function() {
          if (currentFilterExtent.length > 0)
            setMapExtentByBoundingBox(currentFilterExtent[1][1], currentFilterExtent[1][0], currentFilterExtent[0][1], currentFilterExtent[0][0]);
          else
            setMapExtentByLeafletBounds(objectsExtent);
        });

        // Höhe der Karte dynamisch setzen anhand der Höhen der Seitenbereiche
        {% if not request.user_agent.is_mobile and not request.user_agent.is_tablet %}
          let height = $('#map-side-container').position().top;
          $('.side').each(function() {
            height += $(this).height();
          });
          $('#map-side-container').height(height);
          $('#map').height(height);
          currMap.invalidateSize();
        {% endif %}
      });

      /**
       * zeigt alle Layers (= Features) auf der Karte (wieder) an
       */
      function showAllMapFeatures() {
        currMap.eachLayer(function(layer) {
          if (layer.feature) {
            layer.getElement().style.display = '';
            // Layer (= Feature) ausblenden, falls es von initialer Feature-Ausblendung betroffen ist
            {% if map_filter_hide_initial %}
              if (typeof layer.feature.properties.hide_initial !== 'undefined' && layer.feature.properties.hide_initial) {
                layer.setStyle({
                  fill: false,
                  stroke: false,
                  opacity: 0
                });
              }
            {% endif %}
          } else if (layer.id === 'cluster') {
            layer.addLayers(window.removedLayers);
            layer.refreshClusters();
          }
        });
        window.removedLayers = [];
      }

      /**
       * setzt den Kartenausschnitt mittels Kartenzentrum und Zoom-Level
       *
       * @param {string} x - x-Koordinate des Kartenzentrums
       * @param {number} y - y-Koordinate des Kartenzentrums
       * @param {number} zoomLevel - Zoom-Level
       */
      function setMapExtentByXYAndZoomLevel(x, y, zoomLevel) {
        currMap.panTo([y, x]);
        currMap.setZoom(zoomLevel);
      }

      /**
       * setzt den Kartenausschnitt mittels Bounding-Box
       *
       * @param {number} min_x - minimale x-Koordinate
       * @param {number} min_y - minimale y-Koordinate
       * @param {number} max_x - maximale x-Koordinate
       * @param {number} max_y - maximale y-Koordinate
       */
      function setMapExtentByBoundingBox(min_x, min_y, max_x, max_y) {
        currMap.fitBounds([[max_y, max_x], [min_y, min_x]]);
      }

      /**
       * setzt den Kartenausschnitt mittels Leaflet-Bounding-Box-Objekt
       *
       * @param {Object} leafletBounds - Leaflet-Bounding-Box-Objekt
       */
      function setMapExtentByLeafletBounds(leafletBounds) {
        currMap.fitBounds(leafletBounds);
      }

      /**
       * zeigt und behandelt die Resultate der Adressensuche
       *
       * @param {Object} json - Resultate der Adressensuche
       */
      function showResults(json) {

        // Resultate leeren
        results.children().remove();

        // JSON durchgehen und je Feature ein Resultat bauen
        jQuery.each(json.features, function(index, item) {
          // falls Feature nicht historisch ist:
          if (!item.properties.historisch) {
            let titel;
            if (item.properties._title_.indexOf(', ') !== -1)
              titel = item.properties._title_.substring(item.properties._title_.lastIndexOf(', ') + 2);
            else
              titel = item.properties._title_;
            let result = '<div class="result-element" data-feature="' + index + '"><strong>' + titel + '</strong>';
            if (item.properties.gemeindeteil_abkuerzung)
              result += ' <small>(' + item.properties.gemeindeteil_abkuerzung + ')</small>';
            result += '<small class="text-black-50"><em>' + item.properties.objektgruppe.replace(/ HRO/, '') + '</em></small></div>';
            results.append(result);
          }
        });

        // Resultate einblenden
        results.fadeIn();

        // bei Klick auf Resultat Karte auf dieses zoomen
        results.children().on('click', function() {
          let featureGeometry = json.features[$(this).data('feature')].geometry;
          if (featureGeometry.type === 'Point') {
            currMap.fitBounds([
              [
                featureGeometry.coordinates[1],
                featureGeometry.coordinates[0]
              ],
              [
                featureGeometry.coordinates[1],
                featureGeometry.coordinates[0]
              ]
            ]);
          } else {
            currMap.fitBounds([
              [
                featureGeometry.coordinates[0][0][1],
                featureGeometry.coordinates[0][1][0]
              ],
              [
                featureGeometry.coordinates[0][2][1],
                featureGeometry.coordinates[0][0][0]
              ]
            ]);
          }
        });
      }
    </script>
  {% endif %}
{% endblock %}